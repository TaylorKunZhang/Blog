<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android组件化开发规范</title>
    <url>/2020/03/31/android-componentization-guide/</url>
    <content><![CDATA[<p>进行组件化开发有一段时间了，不久后就要开始一个新项目了，为此整理了目前项目中使用的组件化开发规范，方便在下一个项目上使用。本文的重点是介绍规范和项目架构，仅提供示例代码举例，目前不打算提供示例Demo。如果你还不了解什么是组件化以及如何进行组件化开发的话，建议请先看其他组件化入门文章。</p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<p>组件是 <code>Android</code> 项目中一个相对独立的功能模块，是一个抽象的概念，<code>module</code> 是 <code>Android</code> 项目中一个相对独立的代码模块。</p>
<p>在组件化开发的早期，一个组件就只有一个 <code>module</code>，导致很多代码和资源都会下沉到 <code>common</code> 中，导致 <code>common</code> 会变得很臃肿。有的文章说，专门建立一个 <code>module</code> 来存放通用资源，我感觉这样是治标不治本，直到后面看到<a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w">微信Android模块化架构重构实践</a>这篇文章，里面的&quot;模块的一般组织方式&quot;一节提到一个模块应该有多个工程，然后开始在项目对 <code>module</code> 进行拆分。</p>
<p>一般情况下，一个组件有两个 <code>module</code>，一个轻量级的 <code>module</code> 提供外部组件需要和本组件进行交互的接口方法及一些外部组件需要的资源，另一个重量级的 <code>module</code> 完成组件实际的功能和实现轻量级 <code>module</code> 定义的接口方法。</p>
<p><code>module</code> 的命名规范请参考<a href="#module%E5%90%8D">module名</a>，在下文中使用 <code>module-api</code> 代表轻量级的 <code>module</code>，使用 <code>module-impl</code> 代表重量级的 <code>module</code>。</p>
<h2 id="common组件">common组件</h2>
<p><code>common</code> 是一个特殊的组件，不区分轻量级和重量级，它是项目中最底层的组件，基本上所有的其他组件都会依赖 <code>common</code> 组件，<code>common</code> 中放项目中所有弱业务逻辑的代码和解决循环依赖的代码和资源。</p>
<p>一个完整的项目的架构如下：</p>
<p><img src="project-structure.png" alt=""></p>
<h3 id="弱业务逻辑代码">弱业务逻辑代码</h3>
<p>何为弱业务逻辑代码？简单来说，就是有一定的业务逻辑，但是这个业务逻辑对于项目中其他组件来说通用的。</p>
<p>比如在 <code>common</code> 组件集成网络请求库，创建一个 <code>HttpTool</code> 工具类，负责初始化网络请求框架，定义网络请求方法，实现组装通用请求参数以及处理全局通用错误等，对于其他组件直接通过这个工具类进行网络请求就可以了。</p>
<p>比如定义界面基类，处理一些通用业务逻辑，比如接入统计分析框架。</p>
<h3 id="解决循环依赖的代码和资源">解决循环依赖的代码和资源</h3>
<p>何为解决循环依赖的代码和资源？比如说 <code>module-a-api</code> 有一个类 <code>C</code>，<code>module-b-api</code> 中有一个类 <code>D</code>，在 <code>module-a-api</code> 中需要使用 <code>D</code>，在 <code>module-b-api</code> 中需要使用 <code>C</code>，这样就会造成  <code>module-a-api</code> 需要依赖  <code>module-b-api</code>，而 <code>module-b-api</code> 也会依赖 <code>module-a-api</code>，这就造成了循环依赖，在 <code>Android Studio</code> 中会编译失败。</p>
<p>解决循环依赖的方案就是将 <code>C</code> 和 <code>D</code> 其中的一个，或者两个都下沉到 <code>common</code> 组件中，因为 <code>module-a-api</code> 和  <code>module-b-api</code> 都依赖了 <code>common</code> 组件，至于具体下沉几个，这个根据具体的情况而定，但是原则是<strong>下沉到 <code>common</code> 组件的东西越少越好。</strong></p>
<p>上面的举的例子是代码，资源文件同样也可能会有这个问题。</p>
<h2 id="module代码结构">module代码结构</h2>
<p>一个组件通常含有一个或多个功能点，比如对于用户组件，它有关于界面、意见反馈、修改账户密码等功能点，在 <code>module</code> 中为每一个功能点创建一个路径，里面放实现该功能的代码，比如 <code>Activity</code>、<code>Dialog</code> 、<code>Adapter</code> 等。除此之外，为了集中管理组件内部资源和统一编码习惯，特地将一部分的通用功能路径固定下来。这些路径包括 <code>api</code>、<code>provider</code>、<code>tool</code> 等。</p>
<p>一般情况下 <code>module</code> 的代码架构如下图：</p>
<p><img src="module-code-structure.png" alt=""></p>
<h3 id="api">api</h3>
<p>该路径下放 <code>module</code> 内部使用到的所有网络请求路径和方法，一般使用一个类就够了，比如：<code>UserApi</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserApi &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取个人中心数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPersonCenterData</span><span class="params">()</span></span>: GetRequest &#123;</span><br><span class="line">        <span class="keyword">return</span> HttpTool.<span class="keyword">get</span>(ApiVersion.v1_0_0 + <span class="string">&quot;authUser/myCenter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApiVersion</code> 全局管理目前项目中使用的所有 <code>api</code> 版本，应当定义在 <code>common</code> 组件的 <code> api</code> 路径下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ApiVersion &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> v1_0_0 = <span class="string">&quot;v1/&quot;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> v1_1_0 = <span class="string">&quot;v1_1/&quot;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> v1_2_2 = <span class="string">&quot;v1_2_2/&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="entity">entity</h3>
<p>该路径下放 <code>module</code> 内部使用到的所有实体类（网络请求返回的数据类）。</p>
<p>对于所有从服务器获取的字段，全部定义在构造函数中，且实体类应当实现 <code>Parcelable</code> ，并使用 <code>@Parcelize</code> 注解。对于客户端使用而自己定义的字段，基本上定义为普通成员字段，并使用 <code>@IgnoredOnParcel</code> 注解，如果需要在界面间传递客户端定义的字段，可以将该字段定义在构造函数中，但是必须注明是客户端定义的字段。</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductEntity</span></span>(</span><br><span class="line">    <span class="comment">// 产品名称</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产品图标</span></span><br><span class="line">    <span class="keyword">var</span> icon: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产品数量（客户端定义字段）</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : Parcelable &#123;</span><br><span class="line">    <span class="comment">// 用户是否选择本产品</span></span><br><span class="line">    <span class="meta">@IgnoredOnParcel</span></span><br><span class="line">    <span class="keyword">var</span> isSelected = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>name</code> 和 <code>icon</code> 是从服务器获取的字段，而 <code>count</code> 和 <code>isSelected</code> 是客户端自己定义的字段。</p>
<h3 id="event">event</h3>
<p>该路径下放 <code>module</code> 内部使用的事件相关类。对于使用了 <code>EventBus</code> 及类似框架的项目，放事件类，对于使用了 <code>LiveEventBus</code> 的项目，里面只需要放一个类就好，比如：<code>UserEvent</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserEvent &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新用户信息成功事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> updateUserInfoSuccessEvent: LiveEventBus.Event&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line">        <span class="keyword">get</span>() = LiveEventBus.<span class="keyword">get</span>(<span class="string">&quot;user_update_user_info_success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对于使用 <code>LiveEventBus</code> 的项目，事件的命名必须用组件名作为前缀，防止事件名重复。</p>
</blockquote>
<h3 id="route">route</h3>
<p>该路径下放 <code>module</code> 内部所使用到的界面路径和跳转方法，一般使用一个类就够了，比如：<code>UserRoute</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserRoute &#123;</span><br><span class="line">    <span class="comment">// 关于界面</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ABOUT = <span class="string">&quot;/user/about&quot;</span></span><br><span class="line">    <span class="comment">// 常见问题（H5）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> FAQ = <span class="string">&quot;FAQ/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转至关于界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toAbout</span><span class="params">()</span></span>: RouteNavigation &#123;</span><br><span class="line">        <span class="keyword">return</span> RouteNavigation(ABOUT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转至常见问题（H5）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toFAQ</span><span class="params">()</span></span>: RouteNavigation? &#123;</span><br><span class="line">        <span class="keyword">return</span> RouteUtil.getServiceProvider(IH5Service::<span class="keyword">class</span>.java)</span><br><span class="line">            ?.toH5Activity(FAQ)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对于组件内部会跳转的H5界面链接也应当写在路由类中。</p>
</blockquote>
<h3 id="provider">provider</h3>
<p>该路径下放对外部 <code>module</code> 提供的服务，一般使用一个类就够了。在 <code>module-api</code>  中是一个接口类，在 <code>module-impl</code> 中是该接口类的实现类。</p>
<p>目前采用 <a href="https://github.com/alibaba/ARouter">ARouter</a> 作为组件化的框架，为了解耦，对其进行了封装，封装示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Route = com.alibaba.android.arouter.facade.<span class="keyword">annotation</span>.Route</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> RouteUtil &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">getServiceProvider</span><span class="params">(service: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">return</span> ARouter.getInstance().navigation(service)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteNavigation</span></span>(path: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> postcard = ARouter.getInstance().build(path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">param</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">Int</span>)</span></span>: RouteNavigation &#123;</span><br><span class="line">        postcard.withInt(key, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例">示例</h4>
<p>这里介绍如何在外部 <code>module</code> 和 <code>user-impl</code> 跳转至用户组件中的关于界面。</p>
<h5 id="准备工作">准备工作</h5>
<p>在 <code>user-impl</code> 中创建路由类，编写关于界面的路由和服务路由及跳转至关于界面方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserRoute &#123;</span><br><span class="line">    <span class="comment">// 关于界面</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> ABOUT = <span class="string">&quot;/user/about&quot;</span></span><br><span class="line">    <span class="comment">// 用户组件服务</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> USER_SERVICE = <span class="string">&quot;/user/service&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转至关于界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toAbout</span><span class="params">()</span></span>: RouteNavigation &#123;</span><br><span class="line">        <span class="keyword">return</span> RouteNavigation(ABOUT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在关于界面使用路由：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route(path = UserRoute.ABOUT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AboutActivity</span> : <span class="type">MyBaseActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>user-api</code> 中定义跳转界面方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> : <span class="type">IServiceProvider &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转至关于界面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toAbout</span><span class="params">()</span></span>: RouteNavigation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>user-impl</code> 中实现跳转界面方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route(path = UserRoute.USER_SERVICE)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> : <span class="type">IUserService &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toAbout</span><span class="params">()</span></span>: RouteNavigation &#123;</span><br><span class="line">        <span class="keyword">return</span> UserRoute.toAbout()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="界面跳转">界面跳转</h5>
<p>在 <code>user-impl</code> 中可以直接跳转到关于界面：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">UserRoute.toAbout().navigation(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>假设 <code>module-a</code> 需要跳转到关于界面，那么先在 <code>module-a</code> 中配置依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation project(<span class="string">&#x27;:user-api&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>module-a</code> 中使用 <strong><code>provider </code></strong> 跳转到关于界面：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">RouteUtil.getServiceProvider(IUserService::<span class="keyword">class</span>.java)</span><br><span class="line">    ?.toAbout()</span><br><span class="line">    ?.navigation(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<h5 id="module依赖关系">module依赖关系</h5>
<p>此时各个 <code>module</code> 的依赖关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">common：基础库、第三方库</span><br><span class="line">user-api：common</span><br><span class="line">user-impl：common、user-api</span><br><span class="line">module-a：common、user-api</span><br><span class="line">App壳：common、user-api、user-impl、module-a、...</span><br></pre></td></tr></table></figure>
<h3 id="tool">tool</h3>
<p>该路径下放 <code>module</code> 内部使用的工具方法，一般一个类就够了，比如：<code>UserTool</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserTool &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该用户是否是会员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gradeId 会员等级id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isMembership</span><span class="params">(gradeId: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gradeId &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cache">cache</h3>
<p>该路径下放 <code>module</code> 使用的缓存方法，一般一个类就够了，比如：<code>UserCache</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> UserCache &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索历史记录列表</span></span><br><span class="line">    <span class="keyword">var</span> searchHistoryList: ArrayList&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> cacheStr = CacheTool.userCache.getString(SEARCH_HISTORY_LIST)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (cacheStr == <span class="literal">null</span>) &#123;</span><br><span class="line">                ArrayList()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                JsonUtil.parseArray(cacheStr, String::<span class="keyword">class</span>.java) ?: ArrayList()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            CacheTool.userCache.put(SEARCH_HISTORY_LIST, JsonUtil.toJson(value))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索历史记录列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SEARCH_HISTORY_LIST = <span class="string">&quot;user_search_history_list&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>缓存Key的命名必须用组件名作为前缀，防止缓存Key重复。</li>
<li><code>CacheTool.userCache</code> 并不是指用户组件的缓存，而是用户的缓存，即当前登录账号的缓存，每个账号会单独存一份数据，相互之间没有干扰。与之对应的是 <code>CacheTool.globalCache</code>，全局缓存，所有的账号会共用一份数据。</li>
</ol>
</blockquote>
<h2 id="两种module的区别">两种module的区别</h2>
<p><code>module-api</code> 中放的都是外部组件需要的，或者说外部组件和 <code>module-impl</code> 都需要的，其他的都应当放在 <code>module-impl</code> 中，对于外部组件需要的但是能通过 <strong><code>provider</code></strong> 方式提供的，都应当把具体的实现放在 <code>module-impl</code> 中，<code>module-api</code> 中只是放一个接口方法。</p>
<p>下表列举项目开发中哪些东西能否放 <code>module-api</code> 中：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>能否放 <code>module-api</code></th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能界面(Activity、Fragment、Dialog)</td>
<td>不能</td>
<td>通过 <strong><code>provider</code></strong> 方式提供使用</td>
</tr>
<tr>
<td>基类界面</td>
<td>部分能</td>
<td>外部 <code>module</code> 需要使用的可以，其他的放 <code>module-impl</code> 中</td>
</tr>
<tr>
<td>adapter</td>
<td>部分能</td>
<td>外部 <code>module</code> 需要使用的可以，其他的放 <code>module-impl</code> 中</td>
</tr>
<tr>
<td>provider</td>
<td>部分能</td>
<td>只能放接口类，实现类放 <code>module-impl</code> 中</td>
</tr>
<tr>
<td>tool</td>
<td>部分能</td>
<td>外部 <code>module</code> 需要使用的可以，其他的放 <code>module-impl</code> 中</td>
</tr>
<tr>
<td>api、route、cache</td>
<td>不能</td>
<td>通过 <strong><code>provider</code></strong> 方式提供使用</td>
</tr>
<tr>
<td>entity</td>
<td>部分能</td>
<td>外部 <code>module</code> 需要使用的可以，其他的放 <code>module-impl</code> 中</td>
</tr>
<tr>
<td>event</td>
<td>部分能</td>
<td>对使用 <code>EventBus</code> 及类似框架的项目，外部组件需要的可以，其他还是放 <code>module-impl</code> 中<br/>对于使用了 <code>LiveEventBus</code> 的项目不能，通过 <strong><code>provider</code></strong> 方式提供使用</td>
</tr>
<tr>
<td>资源文件和资源变量</td>
<td>部分能</td>
<td>需要在 <code>xml</code> 文件中使用的可以， 其他的通过 <strong><code>provider</code></strong> 方式提供使用</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：如果仅在 <code>module-impl</code> 中存在工具类，则该工具类命名为 <code>xxTool</code>。如果 <code>module-api</code> 和 <code>module-impl</code> 都存在工具类，则 <code>module-api</code> 中的命名为 <code>xxTool</code>，<code>module-impl</code> 中的命名为 <code>xxTool2</code>。</p>
</blockquote>
<h2 id="组件单独调试">组件单独调试</h2>
<p>在开发过程中，为了查看运行效果，需要运行整个App，比较麻烦，而且可能依赖的其他组件也在开发中，App可能运行不到当前开发的组件。为此可以采用组件单独调试的模式进行开发，减少其他组件的干扰，等开发完成后再切换回 <code>library </code> 的模式。</p>
<p>在组件单独调试模式下，可以增加一些额外的代码来方便开发和调试，比如新增一个入口 <code>Actvity</code>，作为组件单独运行时的第一个界面。</p>
<h3 id="示例-2">示例</h3>
<p>这里介绍在 <code>user-impl</code> 中进行组件单独调试。</p>
<p>在项目根目录下的 <code>gradle.properties</code> 文件中新增变量 <code>isDebugModule</code>，通过该变量控制是否进行组件单独调试：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 组件单独调试开关，为ture时进行组件单独调试</span></span><br><span class="line"><span class="attr">isDebugModule</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure>
<p>在 <code>user-impl</code> 的 <code>build.gradle</code> 的顶部增加以下代码来控制 <code>user-impl</code> 在 <code>Applicaton</code> 和 <code>Library</code> 之间进行切换：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDebugModule.toBoolean()) &#123;</span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>user-impl</code> 的 <code>src/main</code> 的目录下创建两个文件夹 <code>release</code> 和 <code>debug</code>，<code>release</code> 中放 <code>library</code> 模式下的 <code>AndroidManifest.xml</code>，<code>debug</code> 放 <code>application</code> 模式下的 <code>AndroidManifest.xml</code>、代码和资源，如下图所示：</p>
<p><img src="module-debug-structure.png" alt=""></p>
<p>在 <code>user-impl</code> 的 <code>build.gradle</code> 中配置上面的创建的代码和资源路径：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugModule.toBoolean()) &#123;</span><br><span class="line">            main.manifest.srcFile <span class="string">&#x27;src/main/debug/AndroidManifest.xml&#x27;</span></span><br><span class="line">            main.java.srcDirs += <span class="string">&#x27;src/main/debug&#x27;</span></span><br><span class="line">            main.res.srcDirs += <span class="string">&#x27;src/main/debug&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            main.manifest.srcFile <span class="string">&#x27;src/main/release/AndroidManifest.xml&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：完成上述配置后，在 <code>library</code> 模式下，<code>debug</code> 中的代码和资源不会合并到项目中。</p>
</blockquote>
<p>最后在 <code>user-impl</code> 的 <code>build.gradle</code> 中配置 <code>applicationId</code>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugModule.toBoolean()) &#123;</span><br><span class="line">            applicationId <span class="string">&quot;cc.tarylorzhang.demo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果碰到65536的问题，在 <code>user-impl</code> 的 <code>build.gradle</code> 中新增以下配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (isDebugModule.toBoolean()) &#123;</span><br><span class="line">            multiDexEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上工作都完成后，将 <code>isDebugModule</code> 的值改为 <code>true</code>，则可以开始单独调试用户组件。</p>
<h2 id="命名规范">命名规范</h2>
<h3 id="module名">module名</h3>
<p>组件名如果是单个单词的，直接使用该单词 + <code>api</code> 或 <code>impl</code> 的后缀作为 <code>module</code> 名，如果是多个单词的，多个单词小写使用 <code>-</code> 字符作为连接符，然后在其基础上加 <code>api</code> 或 <code>impl</code> 的后缀作为 <code>module</code> 名。</p>
<h4 id="示例-3">示例</h4>
<p>用户组件(<code>User</code>)，它的 <code>module</code> 名为 <code>user-api</code> 和 <code>user-impl</code>；会员卡组件(<code>MembershipCard</code>)，它的 <code>module</code> 名为 <code>membership-card-api</code> 和 <code>membership-card-impl</code>。</p>
<h3 id="包名">包名</h3>
<p>在应用的 <code>applicationId</code> 的基础上增加组件名后缀作为组件基础包名。</p>
<p>在代码中的包名 <code>module-api</code> 和 <code>module-impl</code> 都直接使用基础包名即可，但是在 <code>Android</code> 中项目 <code>AndroidManifest.xml</code> 文件中的 <code>package</code> 不能重复，否则编译不通过。所以 <code>module-impl</code> 中的 <code>package</code> 使用基础包名，而 <code>module-impl</code> 中的 <code>package</code> 使用基础包名 + <code>api</code> 后缀。</p>
<blockquote>
<p>package 重复的时候，会报 Type package.BuildConfig is defined multiple times 的错误。</p>
</blockquote>
<h4 id="示例-4">示例</h4>
<p>应用的 <code>applicationId</code> 为 <code>cc.taylorzhang.demo</code>，对于用户组件(<code>user</code>)，组件基础包名为 <code>cc.taylorzhang.demo.user</code>，则实际包名如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>代码中的包名</th>
<th>AndroidManifest.xml中的包名</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user-api</code></td>
<td><code>cc.taylorzhang.demo.user</code></td>
<td><code>cc.taylorzhang.demo.userapi</code></td>
</tr>
<tr>
<td><code>user-impl</code></td>
<td><code>cc.taylorzhang.demo.user</code></td>
<td><code>cc.taylorzhang.demo.user</code></td>
</tr>
</tbody>
</table>
<p>对于多单词的会员卡组件(<code>MembershipCard</code>)，其组件基础包名为 <code>cc.taylorzhang.demo.membershipcard</code>。</p>
<h3 id="资源文件和资源变量">资源文件和资源变量</h3>
<p>所有的资源文件：布局文件、图片等全部要增加组件名作为前缀，所有的资源变量：字符串、颜色等也全部要增加组件名作为前缀，防止资源名重复。</p>
<h4 id="示例-5">示例</h4>
<ul>
<li>用户组件(<code>User</code>)，关于界面布局文件命名为：<code>user_activity_about.xml</code>；</li>
<li>用户组件(<code>User</code>)，关于界面标题字符串命名为：<code>user_about_title</code>；</li>
<li>会员卡组件(<code>MembershipCard</code>)，会员卡详情界面布局文件，文件名为：<code>membership_card_activity_detail</code>；</li>
<li>会员卡组件(<code>MembershipCard</code>)，会员卡详情界面标题字符串，文件名为：<code>membership_card_detail_title</code>；</li>
</ul>
<h3 id="类名">类名</h3>
<p>对于类名没必要增加前缀，比如 <code>UserAboutActivity</code>，因为对资源文件和资源变量增加前缀主要是为了避免重复定义资源导致资源被覆盖的问题，而上面的包名命名规范已经避免了类重复的问题，直接命名 <code>AboutActivity</code> 即可。</p>
<h2 id="全局管理App环境">全局管理App环境</h2>
<p><code>App</code> 环境一般分为开发、测试和生产环境，不同环境下使用的网络请求地址大概率是不一样的，甚至一些UI都不一样，在打包的时候手动修改很容易有遗漏，产生不必要的 <code>BUG</code>。应当使用 <code>buildConfigField</code> 在打包的时候将当前环境写入 <code>App</code> 中，在代码中根据读取环境变量，根据不同的环境执行不同的操作。</p>
<h3 id="示例-6">示例</h3>
<h4 id="准备工作-2">准备工作</h4>
<p>在 <code>App</code> 壳 的 <code>build.gradle</code> 中给每个<code>buildType</code> 都配置 <code>APP_ENV</code>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            buildConfigField <span class="string">&quot;String&quot;</span>, <span class="string">&quot;APP_ENV&quot;</span>, <span class="string">&#x27;\&quot;dev\&quot;&#x27;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField <span class="string">&quot;String&quot;</span>, <span class="string">&quot;APP_ENV&quot;</span>, <span class="string">&#x27;\&quot;release\&quot;&#x27;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ctest &#123;</span><br><span class="line">            initWith release</span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">&quot;String&quot;</span>, <span class="string">&quot;APP_ENV&quot;</span>, <span class="string">&#x27;\&quot;test\&quot;&#x27;</span></span><br><span class="line">            matchingFallbacks = [<span class="string">&#x27;release&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：测试环境的 <code>buildType</code> 不能使用 <code>test</code> 作为名字，<code>Android Studio</code> 会报 <code>ERROR: BuildType names cannot start with 'test'</code>，这里在 <code>test</code> 前增加了一个 <code>c</code>。</p>
</blockquote>
<p>在 <code>common</code> 的 <code>tool</code> 路径下创建一个App环境工具类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> AppEnvTool &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 开发环境 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> APP_ENV_DEV = <span class="string">&quot;dev&quot;</span></span><br><span class="line">    <span class="comment">/** 测试环境 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> APP_ENV_TEST = <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="comment">/** 生产环境 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> APP_ENV_RELEASE = <span class="string">&quot;release&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前App环境，默认为开发环境 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> curAppEnv = APP_ENV_DEV</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(env: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        curAppEnv = env</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前是否处于开发环境 */</span></span><br><span class="line">    <span class="keyword">val</span> isDev: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = curAppEnv == APP_ENV_DEV</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前是否处于测试环境 */</span></span><br><span class="line">    <span class="keyword">val</span> isTest: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = curAppEnv == APP_ENV_TEST</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前是否处于生产环境 */</span></span><br><span class="line">    <span class="keyword">val</span> isRelease: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = curAppEnv == APP_ENV_RELEASE</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Application</code> 中初始化App环境工具类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化App环境工具类</span></span><br><span class="line">        AppEnvTool.<span class="keyword">init</span>(BuildConfig.APP_ENV)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用App环境工具类">使用App环境工具类</h4>
<p>这里介绍根据App环境使用不同的网络请求地址：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> CommonApi &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// api开发环境地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> API_DEV_URL = <span class="string">&quot;https://demodev.taylorzhang.cc/api/&quot;</span></span><br><span class="line">    <span class="comment">// api测试环境地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> API_TEST_URL = <span class="string">&quot;https://demotest.taylorzhang.cc/api/&quot;</span></span><br><span class="line">    <span class="comment">// api生产环境地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> API_RELEASE_URL = <span class="string">&quot;https://demo.taylorzhang.cc/api/&quot;</span></span><br><span class="line">    <span class="comment">// api地址</span></span><br><span class="line">    <span class="keyword">val</span> API_URL = getUrlByEnv(API_DEV_URL, API_TEST_URL, API_RELEASE_URL)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// H5开发环境地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> H5_DEV_URL = <span class="string">&quot;https://demodev.taylorzhang.cc/m/&quot;</span></span><br><span class="line">    <span class="comment">// H5测试环境地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> H5_TEST_URL = <span class="string">&quot;https://demotest.taylorzhang.cc/m/&quot;</span></span><br><span class="line">    <span class="comment">// H5生产环境地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> H5_RELEASE_URL = <span class="string">&quot;https://demo.taylorzhang.cc/m/&quot;</span></span><br><span class="line">    <span class="comment">// H5地址</span></span><br><span class="line">    <span class="keyword">val</span> H5_URL = getUrlByEnv(H5_DEV_URL, H5_TEST_URL, H5_RELEASE_URL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUrlByEnv</span><span class="params">(devUrl: <span class="type">String</span>, testUrl: <span class="type">String</span>, releaseUrl: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            AppEnvTool.isDev -&gt; devUrl</span><br><span class="line">            AppEnvTool.isTest -&gt; testUrl</span><br><span class="line">            <span class="keyword">else</span> -&gt; releaseUrl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打包">打包</h4>
<p>通过不同的命令打包，打出对应的App环境包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开发环境包</span></span><br><span class="line">./gradlew clean assembleDebug</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打测试环境包</span></span><br><span class="line">./gradlew clean assembleCtest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打生产环境包</span></span><br><span class="line">./gradlew clean assembleRelease</span><br></pre></td></tr></table></figure>
<h2 id="全局管理版本信息">全局管理版本信息</h2>
<p>项目中的 <code>module</code> 变多之后，如果要修改第三方库和App使用的SDK版本是一件很蛋疼的事情。应当建立一个配置文件进行管理，其他地方使用配置文件中设置的版本。</p>
<h3 id="示例-7">示例</h3>
<p>在项目根目录下创建一个配置文件 <code>config.gradle</code>，里面放版本信息：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    compile_sdk_version = <span class="number">28</span></span><br><span class="line">    min_sdk_version = <span class="number">17</span></span><br><span class="line">    target_sdk_version = <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    arouter_compiler_version = <span class="string">&#x27;1.2.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录下的 <code>build.gradle</code> 文件中的最上方使用以下代码引入配置文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">from:</span> <span class="string">&quot;config.gradle&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建 <code>module</code> 后，修改该 <code>module</code> 中的 <code>build.gradle</code> 文件，将 <code>SDK</code> 版本默认值换成配置文件中的变量，按需添加第三方依赖，并使用 <code>$</code> + 配置文件中的变量作为第三方库的版本：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    compileSdkVersion compile_sdk_version</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion min_sdk_version</span><br><span class="line">        targetSdkVersion target_sdk_version</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    kapt <span class="string">&quot;com.alibaba:arouter-compiler:$arouter_compiler_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="混淆">混淆</h2>
<p>混淆文件不应该在 <code>App</code> 壳中集中定义，应当在每个 <code>module</code> 中各自定义自己的混淆。</p>
<h3 id="示例-8">示例</h3>
<p>这里介绍配置 <code>user-impl</code> 的混淆，先在 <code>user-impl</code> 的 <code>build.gradle</code> 中配置消费者混淆文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        consumerProguardFiles <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>proguard-rules.pro</code> 文件中写入该 <code>module</code> 的混淆：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line">-keepclassmembers class cc.taylorzhang.demo.user.entity.** &#123; *; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>组件化开发应当遵守&quot;高内聚，低耦合&quot;的原则，尽量少的对外暴露细节。如果用一句话来总结的话，就是代码和资源能放 <code>module-impl</code> 里面的就都放在  <code>module-impl</code>，因为代码隔离问题实在不能放 <code>module-impl</code> 里面的才放 <code>module-api</code>，最后因为涉及到循环依赖问题的才往 <code>common</code> 中放。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android如何优雅实现通用格式化编辑</title>
    <url>/2021/02/05/android-format-edit/</url>
    <content><![CDATA[<p>格式化编辑的需求一般是从编辑手机号开始的，UI 给出的效果不是11个连续的数字，而是采用3、4、4的形式，每段中间会空一个字符。在技术实现的时候，一般会自定义一个控件 TelEditText 实现功能，随着项目迭代，格式化编辑的需求可能会增加，比如说身份证号、自定义的优惠券码等，这个时候再给每种情况自定义一个控件就没必要了，通过一个控件实现多种格式化编辑需求是更好的方案。</p>
<p>其实还可以更进一步，格式化编辑的核心逻辑就是给 EditText 添加一个 TextWatcher，通过 TextWatcher 中的文本变化回调来调整 EditText 中的文本，所以自定义 EditText 并不是必须的，对于开发者需要调用的字段和方法，可以通过扩展函数的方式提供。</p>
<span id="more"></span>
<h2 id="使用">使用</h2>
<h3 id="格式化编辑手机号">格式化编辑手机号</h3>
<p>布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;androidx.appcompat.widget.AppCompatEditText</span><br><span class="line">    android:id=&quot;@+id/etPhone&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:inputType=&quot;number&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>代码:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// format is &#x27; &#x27;</span></span><br><span class="line">etPhone.setFormatRules(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// format is &#x27;-&#x27;</span></span><br><span class="line">etPhone.setFormatRules(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, formatChar = <span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="format_edit_phone.gif" alt=""></p>
<h3 id="格式化编辑身份证号">格式化编辑身份证号</h3>
<p>布局:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;androidx.appcompat.widget.AppCompatEditText</span><br><span class="line">    android:id=&quot;@+id/etIDNumber&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:digits=&quot;@string/digits_id_number&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>资源:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;digits_id_number&quot;</span>&gt;</span>0123456789xX<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">etIDNumber.setFormatRules(<span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><img src="format_edit_id_number.gif" alt=""></p>
<h3 id="设置监听">设置监听</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">etPhone.setOnFormatEditListener &#123; isComplete, text -&gt;</span><br><span class="line">    <span class="keyword">if</span> (isComplete) &#123; <span class="comment">// 编辑完成</span></span><br><span class="line">        <span class="comment">// 使用 toast 显示移除格式化的文本</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, text, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除格式化的文本">移除格式化的文本</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">etPhone.textWithFormatRemoved</span><br></pre></td></tr></table></figure>
<h2 id="实现原理">实现原理</h2>
<p>自定义一个 TextWatcher，定义一个字段 <code>formatChar</code>，值为格式化字符，默认是空格。定义一个字段 <code>formatCharIndexList</code>，值为 EditText 文本中格式化字符所在位置的列表，比如对于格式化编辑手机号， <code>formatCharIndexList</code> 中的值为 <code>[3, 8]</code>，既在 EditText 文本中格式化字符的位置应该是3和8。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formatChar: <span class="built_in">Char</span> = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> formatCharIndexList = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br></pre></td></tr></table></figure>
<p>EditText 文本发生变化后，如果 EditText 文本的最后一个字符为格式化字符，则删除最后一个字符；然后遍历 EditText 文本中的每一个字符，如果该字符的位置等于格式化字符位置但不是格式化字符，则在该位置插入一个格式化字符，如果该字符的位置不等于格式化字符的位置但又是格式化字符，则删除该格式化字符。</p>
<p>调用 <code>insertFormatChar</code> 或者 <code>deleteChar</code> 后，<code>afterTextChanged</code> 又会立即回调一次，可能会引起多次添加或删除，导致格式化错误。所以每次 <code>afterTextChanged</code> 回调最多进行一次操作，如果后续还需要操作，放在下一次 <code>afterTextChanged</code> 回调中进行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = s?.toString() ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value.last() == formatChar) &#123;</span><br><span class="line">        deleteChar(s, value.lastIndex)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value.forEachIndexed &#123; index, c -&gt;</span><br><span class="line">       <span class="keyword">if</span> (formatCharIndexList.contains(index)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != formatChar) &#123;</span><br><span class="line">                insertFormatChar(s, index)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == formatChar) &#123;</span><br><span class="line">                deleteChar(s, index)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目地址">项目地址</h2>
<p><a href="https://github.com/TaylorKunZhang/format-edit">format-edit</a>，觉得用起来很爽的，请不要吝啬你的 Star ！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>可以单个因子构成一个SKU的实现</title>
    <url>/2020/01/16/choose-specification/</url>
    <content><![CDATA[<p>最近做了一版需求，和淘宝等商城App有些不一样，我们的商品单个因子就可以构成一个SKU，特地记录下来，给也有这种需求的App提供一个思路。</p>
<span id="more"></span>
<p><img src="front_cover.gif" alt=""></p>
<h2 id="需求">需求</h2>
<p>名词解释：</p>
<ul>
<li>规格：即SKU。</li>
<li>因子组：构成商品规格的一个维度，比如：“座位数”。</li>
<li>因子：因子组中具体的一个因子，比如说：“5座及以下”，“6座”，“7座及以上”。</li>
</ul>
<h3 id="灵活的因子">灵活的因子</h3>
<p>每一个因子组<strong>最多只能选择一个因子</strong>，来构成一个规格。</p>
<p>举个例子，假设钣金喷漆栏目里面有一个商品叫做 “前保险杠”，该商品有两个因子组：</p>
<blockquote>
<ul>
<li>漆类
<ul>
<li>普通漆</li>
<li>金属漆</li>
</ul>
</li>
<li>钣金
<ul>
<li>普通钣金</li>
<li>复杂钣金</li>
</ul>
</li>
</ul>
</blockquote>
<p>那么一共可以有8种规格：</p>
<blockquote>
<ul>
<li>普通漆</li>
<li>金属漆</li>
<li>普通钣金</li>
<li>复杂钣金</li>
<li>普通漆-普通钣金</li>
<li>普通漆-复杂钣金</li>
<li>金属漆-普通钣金</li>
<li>金属漆-复杂钣金</li>
</ul>
</blockquote>
<p>在实际情况中，在配置的时候可能会删除几种不需要的规格，比如说删除规格：“普通钣金” 、 “复杂钣金” 和 “金属漆-复杂钣金”。</p>
<p>对用户来说，只选一个 “漆类” 可以构成一个规格，也可以再搭配一个 “钣金” 构成另一种规格。只是选择 “金属漆” 的时候只能选择 “普通钣金”，不能选择 “复杂钣金”。</p>
<p><img src="front_bumper.gif" alt=""></p>
<h3 id="默认选中">默认选中</h3>
<p>在显示选择规格弹窗的时候，默认勾选一组可以构成一个规格的因子，尽量让构成选中的因子位于因子组中靠前的位置。</p>
<p>举个例子，假设后一个商品 “后保险杠” ，它也有 “漆类” 和 “钣金” 两个因子组，删除规格：“普通漆” 和 “普通漆-普通钣金”，可用规格如下：</p>
<blockquote>
<ul>
<li>金属漆</li>
<li>普通钣金</li>
<li>复杂钣金</li>
<li>普通漆-复杂钣金</li>
<li>金属漆-普通钣金</li>
<li>金属漆-复杂钣金</li>
</ul>
</blockquote>
<p>那么默认选中的就是 “普通漆-复杂钣金”。</p>
<p><img src="rear_bumper.gif" alt=""></p>
<h2 id="后端返回数据">后端返回数据</h2>
<p>后台返回的一个商品的 <code>JSON</code> 数据结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;前保险杠&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;factorGroupList&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;漆类&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;id&quot;</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;普通漆&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;specificationList&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">      <span class="attr">&quot;originalPrice&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">&quot;discountPrice&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">&quot;factorIdList&quot;</span>: [</span><br><span class="line">        <span class="number">11</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>factorGroupList</code> 是一个数组，里面的每一项都代表该商品的一个因子组，比如 “漆类”。在因子组中，<code>list</code> 字段中是具体的因子，比如：“普通漆”、“金属漆”。</li>
<li><code>specificationList</code> 是一个数组，里面的每一项都代表该商品的一种可用规格。
<ul>
<li><code>originalPrice</code> 是原价，<code>discountPrice</code> 是折扣价，如果折扣价等于原价，则没有折扣价，这里的单位为分。</li>
<li><code>factorIdList</code> 是一个数组，里面的每一项代表着该规格所包含的因子id。</li>
</ul>
</li>
</ul>
<h2 id="算法思路">算法思路</h2>
<p>因子一共有三种状态，所以在 <code>FactorEntity</code> 里创建了一个枚举类 <code>Status</code>，并新增一个 <code>Status</code> 类型的 <code>status</code> 字段来标识当前因子的状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因子状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DISABLED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVAILABLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SELECTED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到选择规格的逻辑其实和UI逻辑相对独立，所以专门新建了一个类 <code>ChooseSpecificationCalculator</code> 来处理选择规格的计算。</p>
<h3 id="初始化">初始化</h3>
<p>创建一个列表来装当前选中的因子，在选中和取消选中因子的时候对该列表进行增加或者删除因子的操作；</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选中因子列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> selectedFactorList = ArrayList&lt;FactorEntity&gt;()</span><br></pre></td></tr></table></figure>
<p>在  <code>FactorEntity</code>  中新增一个字段 <code>specificationList</code> 放所有包含该因子的规格，这样后续处理该因子的时候不必每次都遍历整个规格列表，只需要在初始化的时候对每一个因子遍历一次整个规格列表就好。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">product.factorGroupList.forEach &#123; factorGroup -&gt;</span><br><span class="line">    factorGroup.list.forEach &#123; factor -&gt;</span><br><span class="line">        factor.specificationList.addAll(product.specificationList.filter &#123;</span><br><span class="line">            it.factorIdList.contains(factor.id)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对每一个因子组遍历一次，删除 <code>specificationList</code> 为空的因子，然后再遍历因子组列表，删除因子数为空的因子组，给剩余的每一个因子 <code>status</code> 赋值为  <code>AVAILABLE</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除没有规格的因子</span></span><br><span class="line">product.factorGroupList.forEach &#123; factorGroup -&gt;</span><br><span class="line">    factorGroup.list = factorGroup.list.filter &#123;</span><br><span class="line">        it.specificationList.isNotEmpty()</span><br><span class="line">    &#125; <span class="keyword">as</span> ArrayList&lt;FactorEntity&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除没有因子的因子组</span></span><br><span class="line">product.factorGroupList = product.factorGroupList.filter &#123;</span><br><span class="line">    it.list.isNotEmpty()</span><br><span class="line">&#125; <span class="keyword">as</span> ArrayList&lt;FactorGroupEntity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认所有因子可用（经过上一步的筛选，剩下的因子至少包含一个规格，在没有选中因子的时候，所有的因子都是可用的）</span></span><br><span class="line">product.factorGroupList.forEach &#123; factorGroup -&gt;</span><br><span class="line">    factorGroup.list.forEach &#123; factor -&gt;</span><br><span class="line">        factor.status = FactorEntity.Status.AVAILABLE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里之所以这么处理是因为需求要求删除无用的因子，如果你们的需求需要保留不可用因子的话，可以判断 <code>specificationList</code> 是否为空，为空的 <code>status</code> 赋值为  <code>DISABLED</code>，不为空的 <code>status</code> 赋值为  <code>AVAILABLE</code>。</p>
</blockquote>
<h3 id="选中因子">选中因子</h3>
<p>只处理可用状态的因子，如果当前因子组存在选中因子，则将该因子变为可用状态，并移除已选中因子列表。然后将本次操作的因子状态置为选中状态，并加入已选中因子列表，然后更新所有因子的状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">selectedFactor</span><span class="params">(factor: <span class="type">FactorEntity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (factor.status != FactorEntity.Status.AVAILABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前因子组存在选中因子，则将该因子变为可用状态</span></span><br><span class="line">    <span class="keyword">val</span> factorGroup = product.factorGroupList.find &#123; it.list.contains(factor) &#125;!!</span><br><span class="line">    factorGroup.list.find &#123; it.status == FactorEntity.Status.SELECTED &#125;?.let &#123;</span><br><span class="line">        removeSelectedFactor(it)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addSelectedFactor(factor)</span><br><span class="line">    updateAllFactorStatus(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取消选中因子">取消选中因子</h3>
<p>只处理处理选中状态的因子，将因子状态置为可用状态，并移除已选中因子列表，然后更新所有因子的状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unselectedFactor</span><span class="params">(factor: <span class="type">FactorEntity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (factor.status != FactorEntity.Status.SELECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    removeSelectedFactor(factor)</span><br><span class="line">    updateAllFactorStatus(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新因子状态">更新因子状态</h3>
<p>这里是算法的核心部分，这里拿判断因子 <code>A</code> 的状态为例。</p>
<p>使用已选中因子列表的因子 <code>id</code> 加上因子 <code>A</code> 的 <code>id</code> 构成一个集合 <code>B</code>，然后去遍历因子 <code>A</code> 的 <code>specificationList</code> 中的规格，看是否能找到一个规格满足集合 <code>B</code> 是其 <code>factorIdList</code> 的子集。</p>
<p>在这里，判断一个集合是另一个集合的子集采用的是 <code>containsAll</code> 方法，你如果需要考虑优化的话，可以参考淘宝团队的<a href="http://git.shepherdwind.com/sku-search-algorithm.html">sku组合查询算法探索</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> find = factor.specificationList.find &#123; specification -&gt;</span><br><span class="line">    specification.factorIdList.containsAll(factorIdList)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (find == <span class="literal">null</span>) &#123;</span><br><span class="line">    factor.status = FactorEntity.Status.DISABLED</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factor.status = FactorEntity.Status.AVAILABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获得选中规格">获得选中规格</h3>
<p>如果选中因子列表为空，则返回 <code>null</code>。</p>
<p>拿出选中因子列表中的第一个因子，遍历该因子的 <code>specificationList</code> 字段中的每一个规格，如果发现有规格满足其字段 <code>factorIdList</code> 的数量等于 <code>selectedFactorList</code> 的数量 ，<code>selectedFactorList</code> 构成的因子 <code>id</code> 集合是其<code>factorIdList</code> 的子集，则该规格为当前因子构成的规格。</p>
<p>如果遍历完后还找不到对应的规格，则返回 <code>null</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSelectedSpecification</span><span class="params">()</span></span>: SpecificationEntity? &#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedFactorList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对包含选中因子列表中第一个的因子的规格进行遍历，查看当前选中的因子列表是否能构成一个规格</span></span><br><span class="line">    <span class="keyword">return</span> selectedFactorList.first().specificationList.find &#123; specification -&gt;</span><br><span class="line">        specification.factorIdList.size == selectedFactorList.size &amp;&amp;</span><br><span class="line">                specification.factorIdList.containsAll(selectedFactorIdList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认选中-2">默认选中</h3>
<p>一开始的时候，觉得这里是一个难点，但是等把上面的算法都实现后，回过头来考虑这个问题的时候，问题已经变得很简单了。</p>
<p>直接遍历因子组列表，从因子组中找到第一个可用的因子，选中它，如果能构成一个规格则结束，否则继续选中下一个因子组中的第一个可用因子，直到构成一个规格。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">run <span class="symbol">breaking@</span>&#123;</span><br><span class="line">    product.factorGroupList.forEach <span class="symbol">forEach1@</span>&#123; factorGroup -&gt;</span><br><span class="line">        factorGroup.list.forEach <span class="symbol">forEach2@</span>&#123; factor -&gt;</span><br><span class="line">            <span class="keyword">if</span> (factor.status == FactorEntity.Status.AVAILABLE) &#123;</span><br><span class="line">                <span class="comment">// 选中该因子</span></span><br><span class="line">                selectedFactor(factor)</span><br><span class="line">                <span class="keyword">if</span> (getSelectedSpecification() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 找到规格，结束寻找</span></span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@breaking</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@forEach1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>这个算法和淘宝等商城App的选择规格算法虽然有一定的差异性，但是把删除的规格当作已经卖完的规格，再加上规格数量，那么就和淘宝等商城App的逻辑差不多了。</p>
<p>项目源码：<a href="https://github.com/TaylorKunZhang/android/tree/master/choose-specification">choose-specification</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SKU</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake使用教程(一)</title>
    <url>/2019/11/18/cmake-tutorial-1/</url>
    <content><![CDATA[<p><code>CMake</code> 是一种跨平台的免费开源软件工具，用于使用与编译器无关的方法来管理软件的构建过程。在 <code>Android Studio</code> 上进行 <code>NDK</code> 开发默认就是使用 <code>CMake</code> 管理 <code>C/C++</code> 代码，因此在学习 <code>NDK</code> 之前最好对 <code>CMake</code> 有一定的了解。</p>
<span id="more"></span>
<p>本文主要以翻译 <code>CMake</code> 的<a href="https://cmake.org/cmake/help/v3.16/guide/tutorial/index.html">官方教程文档</a>为主，加上自己的一些理解，该教程涵盖了 <code>CMake</code> 的常见使用场景。由于能力有限，翻译部分采用机翻+人工校对，翻译有问题的地方，说声抱歉。</p>
<p>开发环境：</p>
<ul>
<li>macOS 10.14.6</li>
<li>CMake 3.15.1</li>
<li>CLion 2018.2.4</li>
</ul>
<h2 id="基础项目">基础项目</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/base-demo">示例程序地址</a></p>
<p>最基础的项目是单个源代码文件构建的可执行文件。</p>
<p>本示例提供的源代码文件是 <code>tutorial.cxx</code>，可用于计算数字的平方根。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert input to double</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> inputValue = <span class="built_in">atof</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate square root</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于简单的项目，只需三行内容的 <code>CMakeLists.txt</code> 文件，这将是本教程的起点。在项目根目录下创建一个 <code>CMakeLists.txt</code> 文件，其内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置运行此配置文件所需的CMake最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="comment"># 添加一个可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，此示例在 <code>CMakeLists.txt</code> 文件中使用小写命令。<code>CMake</code> 支持大写，小写和大小写混合命令。</p>
</blockquote>
<p>当前项目结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── tutorial.cxx</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令生成编译中间文件以及 <code>makefile</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>
<p>命令执行后会在项目根目录下生成文件，项目结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── Makefile</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">└── tutorial.cxx</span><br></pre></td></tr></table></figure>
<p>这样源文件和生成的文件都混在一起，不方便管理，建议使用一个专门的目录管理这些生成的文件。这里使用 <code>CLion</code> 默认生成文件目录 <code>cmake-build-debug</code>，在项目根目录运行编译命令并指定生成文件目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>项目结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── cmake-build-debug</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── cmake_install.cmake</span><br><span class="line">└── tutorial.cxx</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>命令执行后生成了可执行文件 <code>Tutorial</code>，项目结构如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> .</span><br><span class="line"> ├── CMakeLists.txt</span><br><span class="line"> ├── cmake-build-debug</span><br><span class="line"> │   ├── CMakeCache.txt</span><br><span class="line"> │   ├── CMakeFiles</span><br><span class="line"> │   ├── Makefile</span><br><span class="line"><span class="addition">+│   ├── Tutorial</span></span><br><span class="line"> │   └── cmake_install.cmake</span><br><span class="line"> └── tutorial.cxx</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件且不携带参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: .&#x2F;cmake-build-debug&#x2F;Tutorial number</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件并携带参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="添加版本号和配置头文件">添加版本号和配置头文件</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/add-version-and-config-file">示例程序地址</a></p>
<p>我们添加的第一个功能是为我们的可执行文件和项目提供版本号。虽然我们可以仅在源代码中执行此操作，但是使用 <code>CMakeLists.txt</code> 可以提供更大的灵活性。</p>
<p>首先，修改 <code>CMakeLists.txt</code> 文件以设置版本号。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p>然后，配置头文件以将版本号传递给源代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="comment"># 配置头文件以将某些CMake设置传递给源代码</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure>
<p>由于已配置的文件将被写入二进制目录，因此我们必须将该目录添加到路径列表中以搜索包含文件。将以下行添加到CMakeLists.txt文件的末尾：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="comment"># 将二进制目录添加到包含文件的搜索路径中，以便我们找到TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>使用您喜欢的编辑器，在源目录中使用以下内容创建 <code>TutorialConfig.h.in</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; the configured options and settings for Tutorial</span><br><span class="line">&#x2F;&#x2F; 教程的配置选项和设置</span><br><span class="line">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span><br><span class="line">#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span><br></pre></td></tr></table></figure>
<p>当 <code>CMake</code> 配置此头文件时，会在二进制目录下生成一个文件 <code>TutorialConfig.h</code>，会把 <code>TutorialConfig.h.in</code> 中的内容拷贝到里面，只是把 <code>@Tutorial_VERSION_MAJOR@</code> 和 <code>@Tutorial_VERSION_MINOR@</code> 替换成在 <code>CMakeLists.txt</code> 的配置的 1 和 0。</p>
<p>这里的 1 和 0 是怎么和 <code>Tutorial_VERSION_MAJOR</code> 、<code>Tutorial_VERSION_MINOR</code>关联上的? 在 <code>project()</code> 中指定了 <code>VERSION</code> 后，<code>CMake</code> 会把版本信息存储在以下变量中：</p>
<ul>
<li><code>PROJECT_VERSION</code>, <code>&lt;PROJECT-NAME&gt;_VERSION</code></li>
<li><code>PROJECT_VERSION_MAJOR</code>, <code>&lt;PROJECT-NAME&gt;_VERSION_MAJOR</code></li>
<li><code>PROJECT_VERSION_MINOR</code>, <code>&lt;PROJECT-NAME&gt;_VERSION_MINOR</code></li>
<li><code>PROJECT_VERSION_PATCH</code>, <code>&lt;PROJECT-NAME&gt;_VERSION_PATCH</code></li>
<li><code>PROJECT_VERSION_TWEAK</code>, <code>&lt;PROJECT-NAME&gt;_VERSION_TWEAK</code>.</li>
</ul>
<p><code>MAJOR</code>、<code>MINOR</code>、<code>PATCH</code>、<code>TWEAK</code> 分别代表着版本号的四位，比如版本号 <code>1.2.3.4</code>，<code>MAJOR=1</code>、<code>MINOR=2</code>、<code>PATCH=3</code>、<code>TWEAK=4</code>。版本号不一定非得是4位，可以只有1位，只是最大为4位。</p>
<p>这里 <code>PROJECT-NAME</code> 值为 <code>Tutorial</code>，所以能从 <code>Tutorial_VERSION_MAJOR</code> 和 <code>Tutorial_VERSION_MINOR</code> 中读取到版本信息。</p>
<p>当从顶层 <code>CMakeLists.txt</code> 调用 <code>project()</code> 命令时，该版本也存储在变量 <code>CMAKE_PROJECT_VERSION</code> 中。</p>
<p>接下来，修改 <code>tutorial.cxx</code> 以包含配置的头文 <code>件TutorialConfig.h</code> 和打印出版本号，如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// A simple program that computes the square root of a number</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ #include &quot;TutorialConfig.h&quot;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line"><span class="addition">+        // report version</span></span><br><span class="line"><span class="addition">+        std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot;</span></span><br><span class="line"><span class="addition">+                  &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span></span><br><span class="line">        std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // convert input to double</span><br><span class="line">    const double inputValue = atof(argv[1]);</span><br><span class="line"></span><br><span class="line">    // calculate square root</span><br><span class="line">    const double outputValue = sqrt(inputValue);</span><br><span class="line">    std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; inputValue &lt;&lt; &quot; is &quot; &lt;&lt; outputValue</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件且不携带参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;cmake-build-debug&#x2F;Tutorial Version 1.0</span><br><span class="line">Usage: .&#x2F;cmake-build-debug&#x2F;Tutorial number</span><br></pre></td></tr></table></figure>
<h2 id="指定C-标准">指定C++标准</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/specify-standard">示例程序地址</a></p>
<p>在 <code>CMake</code> 中启用对特定 <code>C ++</code> 标准的支持的最简单方法是使用 <code>CMAKE_CXX_STANDARD</code> 变量。对于本教程，请将 <code>CMakeLists.txt</code> 文件中的 <code>CMAKE_CXX_STANDARD</code> 变量设置为11，并将 <code>CMAKE_CXX_STANDARD_REQUIRED</code> 设置为 <code>True</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="comment"># 指定C ++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，通过在 <code>tutorial.cxx</code> 中用 <code>std :: stod</code> 替换 <code>atof</code>，将一些 <code>C ++ 11</code> 功能添加到我们的项目中。同时，删除 <code>#include &lt;cstdlib&gt;</code>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// A simple program that computes the square root of a number</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"><span class="deletion">- #include &lt;cstdlib&gt;</span></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;TutorialConfig.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        // report version</span><br><span class="line">        std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot;</span><br><span class="line">                  &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // convert input to double</span><br><span class="line"><span class="deletion">-    const double inputValue = atof(argv[1]);</span></span><br><span class="line"><span class="addition">+    const double inputValue = std::stod(argv[1]);</span></span><br><span class="line"></span><br><span class="line">    // calculate square root</span><br><span class="line">    const double outputValue = sqrt(inputValue);</span><br><span class="line">    std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; inputValue &lt;&lt; &quot; is &quot; &lt;&lt; outputValue</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="添加库">添加库</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/add-library">示例程序地址</a></p>
<p>现在，我们将添加一个库到我们的项目中，该库用于计算数字的平方根，可执行文件可以使用此库，而不是使用编译器提供的标准平方根函数。该库有两个文件：</p>
<ul>
<li>
<p><code>MathFunctions.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>mysqrt.cxx</code></p>
<p>源文件有一个 <code>mysqrt</code> 的函数，该函数提供与编译器的 <code>sqrt</code> 函数类似的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do ten iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0.1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">        result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在项目根目录下创建一个文件夹 <code>MathFunctions</code> ，把该库放在其下，在其下创建一个 <code>CMakeLists.txt</code> 文件，内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cxx)</span><br></pre></td></tr></table></figure>
<p>为了使用新库，我们将在顶层 <code>CMakeLists.txt</code> 文件中添加 <code>add_subdirectory</code> 调用，以便构建该库。我们将新库添加到可执行文件，并将 <code>MathFunctions</code> 添加为包含目录，以便可以找到 <code>mqsqrt.h</code> 头文件。顶级 <code>CMakeLists.txt</code> 文件的最后几行现在应如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="comment"># 添加 MathFunctions 库</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="comment"># 添加一个可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="comment"># 将二进制目录添加到包含文件的搜索路径中，以便我们找到TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>修改 <code>tutorial.cxx</code> 使用引入的库，其内容如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// A simple program that computes the square root of a number</span><br><span class="line"><span class="deletion">- #include &lt;cmath&gt;</span></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;TutorialConfig.h&quot;</span><br><span class="line"><span class="addition">+ #include &quot;MathFunctions.h&quot;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        // report version</span><br><span class="line">        std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot;</span><br><span class="line">                  &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // convert input to double</span><br><span class="line">    const double inputValue = std::stod(argv[1]);</span><br><span class="line"></span><br><span class="line">    // calculate square root</span><br><span class="line"><span class="deletion">-    const double outputValue = sqrt(inputValue);</span></span><br><span class="line"><span class="addition">+    const double outputValue = mysqrt(inputValue);</span></span><br><span class="line">    std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; inputValue &lt;&lt; &quot; is &quot; &lt;&lt; outputValue</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 2 to be 1.5</span><br><span class="line">Computing sqrt of 2 to be 1.41667</span><br><span class="line">Computing sqrt of 2 to be 1.41422</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="提供选项">提供选项</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/provide-option">示例程序地址</a></p>
<p>现在让我们将 <code>MathFunctions</code> 库设为可选。虽然对于本教程而言确实不需要这样做，但是对于大型项目来说，这是很常见的。第一步是向顶级 <code>CMakeLists.txt</code> 文件添加一个选项：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line"><span class="comment"># 我们应该使用自己的数学函数吗</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>此选项将显示在 <code>CMake GUI</code> 和 <code>ccmake</code> 中，默认值ON可由用户更改。此设置将存储在缓存中，因此用户无需在每次在构建目录上运行CMake时都设置该值。</p>
<p>下一个是使建立和链接 <code>MathFunctions</code> 库成为条件。为此，我们将顶级 <code>CMakeLists.txt</code> 文件的结尾更改为如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="comment"># 添加 MathFunctions 库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">    <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">    <span class="keyword">list</span>(APPEND EXTRA_INCLUDES <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="comment"># 添加一个可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="comment"># 将二进制目录添加到包含文件的搜索路径中，以便我们找到TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        <span class="variable">$&#123;EXTRA_INCLUDES&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，这里使用变量 <code>EXTRA_LIBS</code> 来收集所有可选库，以供以后链接到可执行文件中。变量 <code>EXTRA_INCLUDES</code> 类似地用于可选的头文件。当处理许多可选组件时，这是一种经典方法，我们将在下一步中介绍现代方法。</p>
</blockquote>
<p>对源代码的相应更改非常简单。首先，根据需要在 <code>tutorial.cxx</code> 中决定包含 <code>MathFunctions</code> 头还是 包含 <code>&lt;cmath&gt;</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// should we include the MathFunctions header?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后，在同一文件中，使用 <code>USE_MYMATH</code> 来确定使用哪个平方根函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">mysqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由于源代码现在需要 <code>USE_MYMATH</code>，因此可以使用以下行将其添加到 <code>TutorialConfig.h.in</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cmakedefine USE_MYMATH</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://cmake.org/download/">download</a> 上根据自己的平台下载对应版本的 <code>cmake-gui</code>，安装后打开软件，选择源代码目录和生成文件，如下图所示：</p>
<p><img src="cmake-gui-start.jpg" alt=""></p>
<p>点击左下角 <code>Generate</code> 按钮，软件会弹出的选择项目生成器的弹窗，这里默认就好，点击点击 <code>Done</code> 按钮，<code>cmake-gui</code> 开始编译项目，生成中间文件，并且可以在软件看到我们为用户提供的选项：</p>
<p><img src="cmake-gui-option.jpg" alt=""></p>
<p>这个时候 <code>cmake-build-debug/TutorialConfig.h</code> 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; the configured options and settings for Tutorial</span><br><span class="line">&#x2F;&#x2F; 教程的配置选项和设置</span><br><span class="line">#define Tutorial_VERSION_MAJOR 1</span><br><span class="line">#define Tutorial_VERSION_MINOR 0</span><br><span class="line">#define USE_MYMATH</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 2 to be 1.5</span><br><span class="line">Computing sqrt of 2 to be 1.41667</span><br><span class="line">Computing sqrt of 2 to be 1.41422</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<p>取消 <code>cmake-gui</code> 中的 <code>USE_MYMATH</code> 的勾选，点击 <code>Generate</code> 按钮重新编译项目，这个时候 <code>cmake-build-debug/TutorialConfig.h</code> 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; the configured options and settings for Tutorial</span><br><span class="line">&#x2F;&#x2F; 教程的配置选项和设置</span><br><span class="line">#define Tutorial_VERSION_MAJOR 1</span><br><span class="line">#define Tutorial_VERSION_MINOR 0</span><br><span class="line">&#x2F;* #undef USE_MYMATH *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="CMake使用教程系列文章">CMake使用教程系列文章</h2>
<ul>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-1/">CMake使用教程(一)</a>
<ul>
<li>基础项目</li>
<li>添加版本号和配置头文件</li>
<li>指定C++标准</li>
<li>添加库</li>
<li>提供选项</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-2/">CMake使用教程(二)</a>
<ul>
<li>添加“库”的使用要求</li>
<li>安装</li>
<li>测试</li>
<li>系统自检</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-3/">CMake使用教程(三)</a>
<ul>
<li>指定编译定义</li>
<li>添加自定义命令和生成的文件</li>
<li>生成安装程序</li>
<li>添加对仪表板的支持</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-4/">CMake使用教程(四)</a>
<ul>
<li>混合静态和共享</li>
<li>添加生成器表达式</li>
<li>添加导出配置</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>cmake-tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake使用教程(二)</title>
    <url>/2019/11/18/cmake-tutorial-2/</url>
    <content><![CDATA[<p><code>CMake</code> 是一种跨平台的免费开源软件工具，用于使用与编译器无关的方法来管理软件的构建过程。在 <code>Android Studio</code> 上进行 <code>NDK</code> 开发默认就是使用 <code>CMake</code> 管理 <code>C/C++</code> 代码，因此在学习 <code>NDK</code> 之前最好对 <code>CMake</code> 有一定的了解。</p>
<span id="more"></span>
<p>本文主要以翻译 <code>CMake</code> 的<a href="https://cmake.org/cmake/help/v3.16/guide/tutorial/index.html">官方教程文档</a>为主，加上自己的一些理解，该教程涵盖了 <code>CMake</code> 的常见使用场景。由于能力有限，翻译部分采用机翻+人工校对，翻译有问题的地方，说声抱歉。</p>
<p>开发环境：</p>
<ul>
<li>macOS 10.14.6</li>
<li>CMake 3.15.1</li>
<li>CLion 2018.2.4</li>
</ul>
<h2 id="添加“库”的使用要求">添加“库”的使用要求</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/add-usage-requirements-for-library">示例程序地址</a></p>
<p>使用要求可以更好地控制库或可执行文件的链接和包含行，同时还可以更好地控制 <code>CMake</code> 内部目标的传递属性。利用使用要求的主要命令是：</p>
<ul>
<li>
<p><code>target_compile_definitions</code></p>
<p>给指定目标添加编译定义。</p>
</li>
<li>
<p><code>target_compile_options</code></p>
<p>给指定目标添加编译选项。</p>
</li>
<li>
<p><code>target_include_directories</code></p>
<p>给指定目标添加包含目录。</p>
</li>
<li>
<p><code>target_link_libraries</code></p>
<p>指定链接给定目标或其依赖项时要使用的库或标志。</p>
</li>
</ul>
<p>控制 <code>CMake</code> 内部目标的传递属性有三种类型：</p>
<ul>
<li>
<p><code>PRIVATE</code></p>
<p>属性只应用到本目标，不应用到链接本目标的目标。即生产者需要，消费者不需要。</p>
</li>
<li>
<p><code>PUBLIC</code></p>
<p>属性既应用到本目标也应用到链接目标的目标。即生产者和消费者都需要。</p>
</li>
<li>
<p><code>INTERFACE</code></p>
<p>属性不应用到本目标，应用到链接本目标的目标。即生产者不需要，消费者需要。</p>
</li>
</ul>
<p>让我们重构代码“提供选项”项目的代码，以使用现代 <code>CMake</code> 的使用要求方法。我们首先声明，链接到 <code>MathFunctions</code> 的任何人都需要包含当前源目录，而 <code>MathFunctions</code> 本身不需要。因此，这里使用 <code>INTERFACE</code>。</p>
<p>将以下行添加到 <code>MathFunctions/CMakeLists.txt</code> 的末尾：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="comment"># 说明与我们链接的任何人都需要包含当前源目录才能找到 MathFunctions.h，而我们不需要。</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">        INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>现在，我们已经指定了 <code>MathFunction</code> 的使用要求，我们可以安全地从顶级 <code>CMakeLists.txt</code> 中删除对 <code>EXTRA_INCLUDES</code>变量的使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 2 to be 1.5</span><br><span class="line">Computing sqrt of 2 to be 1.41667</span><br><span class="line">Computing sqrt of 2 to be 1.41422</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="安装">安装</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/cmake-install">示例程序地址</a></p>
<p>安装规则非常简单：对于 <code>MathFunctions</code> ，我们要安装库和头文件，对于应用程序，我们要安装可执行文件和配置的头文件。</p>
<p>因此，在 <code>MathFunctions/CMakeLists.txt</code> 的末尾添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install rules</span></span><br><span class="line"><span class="comment"># 安装规则</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>并在顶级 <code>CMakeLists.txt</code> 的末尾添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the install targets</span></span><br><span class="line"><span class="comment"># 添加安装规则</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS Tutorial DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span></span><br><span class="line">        DESTINATION <span class="keyword">include</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>这就是本地安装所需的全部。</p>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令安装可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --install cmake-build-debug</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>CMake</code> 从3.15开始使用 <code>cmake --install</code> 安装文件。<code>CMake</code> 变量 <code>CMAKE_INSTALL_PREFIX</code> 用于确定文件的安装根目录。如果使用 <code>cmake --install</code>，则可以通过 <code>--prefix</code> 参数指定自定义安装目录。对于多配置工具，请使用 <code>--config</code> 参数指定配置。</p>
</blockquote>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Install configuration: &quot;&quot;</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libMathFunctions.a</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;MathFunctions.h</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;Tutorial</span><br><span class="line">-- Installing: &#x2F;usr&#x2F;local&#x2F;include&#x2F;TutorialConfig.h</span><br></pre></td></tr></table></figure>
<p>在项目根目录执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 2 to be 1.5</span><br><span class="line">Computing sqrt of 2 to be 1.41667</span><br><span class="line">Computing sqrt of 2 to be 1.41422</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<p>这个时候我们调用的不是 <code>cmake-build-debug</code> 下的 <code>Tutorial</code> 文件，而是安装到 <code>/usr/local/bin</code> 目录下的 <code>Tutorial</code> 文件。我们可以通过命令查看一下 <code>Tutorial</code> 的位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">where Tutorial</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;Tutorial</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/cmake-test">示例程序地址</a></p>
<p>接下来，测试我们的应用程序。在顶级 <code>CMakeLists</code> 文件的末尾，我们可以启用测试，然后添加一些基本测试以验证应用程序是否正常运行。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable testing</span></span><br><span class="line"><span class="comment"># 启用测试</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line"><span class="comment"># 测试应用程序是否运行</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line"><span class="comment"># 测试消息是否工作？</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">        PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a function to simplify adding tests</span></span><br><span class="line"><span class="comment"># 定义一个函数以简化添加测试</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">    <span class="keyword">add_test</span>(NAME Comp<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(Comp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">            PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span></span><br><span class="line">            )</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line"><span class="comment"># 做一堆基于结果的测试</span></span><br><span class="line">do_test(Tutorial <span class="number">4</span> <span class="string">&quot;4 is 2&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">9</span> <span class="string">&quot;9 is 3&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">5</span> <span class="string">&quot;5 is 2.236&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">7</span> <span class="string">&quot;7 is 2.645&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">25</span> <span class="string">&quot;25 is 5&quot;</span>)</span><br><span class="line">do_test(Tutorial -<span class="number">25</span> <span class="string">&quot;-25 is [-nan|nan|0]&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">0.0001</span> <span class="string">&quot;0.0001 is 0.01&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>第一个测试只是验证应用程序正在运行，没有段错误或其他崩溃，并且返回值为零。这是 <code>CTest</code> 测试的基本形式。</p>
<p>下一个测试使用 <code>PASS_REGULAR_EXPRESSION</code> 测试属性来验证测试的输出是否包含某些字符串。在这种情况下，验证在提供了错误数量的参数时是否打印了用法消息。</p>
<p>最后，我们有一个名为 <code>do_test</code> 的函数，该函数运行应用程序并验证所计算的平方根对于给定输入是否正确。对于 <code>do_test</code> 的每次调用，都会基于传递的参数将另一个测试添加到项目中，该测试具有名称，输入和预期结果。</p>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令测试应用程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmake-build-debug</span><br><span class="line">ctest</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test project &#x2F;Users&#x2F;taylor&#x2F;Project&#x2F;Taylor&#x2F;C&#x2F;Study&#x2F;cmake-tutorial&#x2F;cmake-test&#x2F;cmake-build-debug</span><br><span class="line">    Start 1: Runs</span><br><span class="line">1&#x2F;9 Test #1: Runs .............................   Passed    0.00 sec</span><br><span class="line">    Start 2: Usage</span><br><span class="line">2&#x2F;9 Test #2: Usage ............................   Passed    0.00 sec</span><br><span class="line">    Start 3: Comp4</span><br><span class="line">3&#x2F;9 Test #3: Comp4 ............................   Passed    0.00 sec</span><br><span class="line">    Start 4: Comp9</span><br><span class="line">4&#x2F;9 Test #4: Comp9 ............................   Passed    0.00 sec</span><br><span class="line">    Start 5: Comp5</span><br><span class="line">5&#x2F;9 Test #5: Comp5 ............................   Passed    0.00 sec</span><br><span class="line">    Start 6: Comp7</span><br><span class="line">6&#x2F;9 Test #6: Comp7 ............................   Passed    0.00 sec</span><br><span class="line">    Start 7: Comp25</span><br><span class="line">7&#x2F;9 Test #7: Comp25 ...........................   Passed    0.00 sec</span><br><span class="line">    Start 8: Comp-25</span><br><span class="line">8&#x2F;9 Test #8: Comp-25 ..........................   Passed    0.00 sec</span><br><span class="line">    Start 9: Comp0.0001</span><br><span class="line">9&#x2F;9 Test #9: Comp0.0001 .......................   Passed    0.00 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 9</span><br><span class="line"></span><br><span class="line">Total Test time (real) &#x3D;   0.03 sec</span><br></pre></td></tr></table></figure>
<h2 id="系统自检">系统自检</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/system-introspection">示例程序地址</a></p>
<p>让我们考虑向我们的项目中添加一些代码，这些代码取决于目标平台可能不具备的功能。</p>
<p>对于此示例，我们将添加一些代码，具体取决于目标平台是否具有 <code>log</code> 和 <code>exp</code> 函数。当然，几乎每个平台都具有这些功能，但对于本教程而言，假定它们并不常见。</p>
<p>如果平台具有 <code>log</code> 和 <code>exp</code> ，那么我们将使用它们来计算 <code>mysqrt</code> 函数中的平方根。我们首先在顶级 <code>CMakeList</code> 中使用 <code>CheckSymbolExists.cmake</code> 宏测试这些功能的可用性。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># does this system provide the log and exp functions?</span></span><br><span class="line"><span class="comment"># 该系统是否提供log和exp函数？</span></span><br><span class="line"><span class="keyword">include</span>(CheckSymbolExists)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_REQUIRED_LIBRARIES <span class="string">&quot;m&quot;</span>)</span><br><span class="line">check_symbol_exists(log <span class="string">&quot;math.h&quot;</span> HAVE_LOG)</span><br><span class="line">check_symbol_exists(exp <span class="string">&quot;math.h&quot;</span> HAVE_EXP)</span><br></pre></td></tr></table></figure>
<p>在 <code>TutorialConfig.h</code> 的 <code>configure_file</code> 命令之前完成对 <code>log</code> 和 <code>exp</code> 的测试非常重要，<code>configure_file</code> 命令使用 <code>CMake</code> 中的当前设置立即配置文件，所以 <code>check_symbol_exists</code> 命令应该放在 <code>configure_file</code> 之前。</p>
<p>现在，将这些定义添加到 <code>TutorialConfig.h.in</code> 中，以便我们可以从 <code>mysqrt.cxx</code>中使用它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; does the platform provide exp and log functions?</span><br><span class="line">&#x2F;&#x2F; 平台是否提供log和exp函数？</span><br><span class="line">#cmakedefine HAVE_LOG</span><br><span class="line">#cmakedefine HAVE_EXP</span><br></pre></td></tr></table></figure>
<p>更新 <code>MathFunctions/CMakeLists.txt</code> 文件，以便 <code>mysqrt.cxx</code>知道此文件的位置：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">          INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">          PRIVATE <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span></span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>修改 <code>mysqrt.cxx</code> 以包含 <code>cmath</code> 和 <code>TutorialConfig.h</code>。接下来，在 <code>mysqrt</code>函数的同一文件中，我们可以使用以下代码（如果在系统上可用）提供基于 <code>log</code> 和 <code>exp</code> 的替代实现（在返回结果前不要忘记 <code>#endif</code> ！）：</p>
<p>我们将在 <code>TutorialConfig.h.in</code> 中使用新定义，因此请确保在配置该文件之前进行设置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_LOG) &amp;&amp; defined(HAVE_EXP)</span></span><br><span class="line">    <span class="keyword">double</span> result = <span class="built_in">exp</span>(<span class="built_in">log</span>(x) * <span class="number">0.5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result</span><br><span class="line">              &lt;&lt; <span class="string">&quot; using log and exp&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line">    <span class="comment">// do ten iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0.1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">        result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 2 to be 1.41421 using log and exp</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="CMake使用教程系列文章">CMake使用教程系列文章</h2>
<ul>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-1/">CMake使用教程(一)</a>
<ul>
<li>基础项目</li>
<li>添加版本号和配置头文件</li>
<li>指定C++标准</li>
<li>添加库</li>
<li>提供选项</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-2/">CMake使用教程(二)</a>
<ul>
<li>添加“库”的使用要求</li>
<li>安装</li>
<li>测试</li>
<li>系统自检</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-3/">CMake使用教程(三)</a>
<ul>
<li>指定编译定义</li>
<li>添加自定义命令和生成的文件</li>
<li>生成安装程序</li>
<li>添加对仪表板的支持</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-4/">CMake使用教程(四)</a>
<ul>
<li>混合静态和共享</li>
<li>添加生成器表达式</li>
<li>添加导出配置</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>cmake-tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake使用教程(三)</title>
    <url>/2019/11/18/cmake-tutorial-3/</url>
    <content><![CDATA[<p><code>CMake</code> 是一种跨平台的免费开源软件工具，用于使用与编译器无关的方法来管理软件的构建过程。在 <code>Android Studio</code> 上进行 <code>NDK</code> 开发默认就是使用 <code>CMake</code> 管理 <code>C/C++</code> 代码，因此在学习 <code>NDK</code> 之前最好对 <code>CMake</code> 有一定的了解。</p>
<span id="more"></span>
<p>本文主要以翻译 <code>CMake</code> 的<a href="https://cmake.org/cmake/help/v3.16/guide/tutorial/index.html">官方教程文档</a>为主，加上自己的一些理解，该教程涵盖了 <code>CMake</code> 的常见使用场景。由于能力有限，翻译部分采用机翻+人工校对，翻译有问题的地方，说声抱歉。</p>
<p>开发环境：</p>
<ul>
<li>macOS 10.14.6</li>
<li>CMake 3.15.1</li>
<li>CLion 2018.2.4</li>
</ul>
<h2 id="指定编译定义">指定编译定义</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/specify-compile-definition">示例程序地址</a></p>
<p>在上一步 “系统自检” 中，除了在 <code>TutorialConfig.h</code> 中保存 <code>HAVE_LOG</code> 和 <code>HAVE_EXP</code> 值之外，还有更好的做法吗？对于此示例，我们将尝试使用 <code>target_compile_definitions</code>。</p>
<p>首先，从 <code>TutorialConfig.h.in</code> 中删除上一步的定义，在 <code>mysqrt.cxx</code> 中不再包含 <code>TutorialConfig.h</code>，移除上一步在 <code>MathFunctions/CMakeLists.txt</code> 中增加的额外包含。</p>
<p>接下来，我们可以将 <code>HAVE_LOG</code> 和 <code>HAVE_EXP</code> 的检查移至 <code>MathFunctions/CMakeLists.txt</code>，然后添加将这些值指定为 <code>PRIVATE</code> 编译定义。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># does this system provide the log and exp functions?</span></span><br><span class="line"><span class="comment"># 该系统是否提供log和exp函数？</span></span><br><span class="line"><span class="keyword">include</span>(CheckSymbolExists)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_REQUIRED_LIBRARIES <span class="string">&quot;m&quot;</span>)</span><br><span class="line">check_symbol_exists(log <span class="string">&quot;math.h&quot;</span> HAVE_LOG)</span><br><span class="line">check_symbol_exists(exp <span class="string">&quot;math.h&quot;</span> HAVE_EXP)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(MathFunctions</span><br><span class="line">                             PRIVATE <span class="string">&quot;HAVE_LOG&quot;</span> <span class="string">&quot;HAVE_EXP&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>完成这些更新后，在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 2 to be 1.41421 using log and exp</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="添加自定义命令和生成的文件">添加自定义命令和生成的文件</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/custom-command-and-generated-file">示例程序地址</a></p>
<p>假设，出于本教程的目的，我们决定不再使用平台日志和exp函数，而是希望生成一个可在 <code>mysqrt</code> 函数中使用的预计算值表。在本节中，我们将在构建过程中创建表，然后将该表编译到我们的应用程序中。</p>
<p>首先，让我们取消对 <code>MathFunctions/CMakeLists.txt</code> 中的 <code>log</code>和 <code>exp</code> 函数的检查。然后从 <code>mysqrt.cxx</code> 中删除对 <code>HAVE_LOG</code> 和 <code>HAVE_EXP</code> 的检查。同时，我们可以删除 <code>#include &lt;cmath&gt;</code>。</p>
<p>在 <code>MathFunctions</code> 子目录中，提供了一个名为 <code>MakeTable.cxx</code> 的新源文件来生成表。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">// A simple program that builds a sqrt table</span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // make sure we have enough arguments</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ofstream fout(argv[<span class="number">1</span>], std::ios_base::out);</span><br><span class="line">    const bool fileOpen = fout.is_open();</span><br><span class="line">    <span class="keyword">if</span> (fileOpen) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;double sqrtTable[] = &#123;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        for (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            fout &lt;&lt; sqrt(static_cast&lt;double&gt;(i)) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        // close the table with a zero</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;0&#125;;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        fout.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileOpen ? <span class="number">0</span> : <span class="number">1</span>; // <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> wrote the <span class="keyword">file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到生成的表不是简单的文本，而是一段C++代码。并且该文件的文件名是由参数传入决定的。</p>
<p>下一步是将适当的命令添加到 <code>MathFunctions/CMakeLists.txt</code> 文件中，以构建<code>MakeTable</code> 可执行文件，然后在构建过程中运行它。需要一些命令来完成此操作。</p>
<p>首先，在 <code>MathFunctions/CMakeLists.txt</code> 的顶部，添加 <code>MakeTable</code> 的可执行文件，就像添加任何其他可执行文件一样。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first we add the executable that generates the table</span></span><br><span class="line"><span class="comment"># 首先，我们添加生成表的可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MakeTable MakeTable.cxx)</span><br></pre></td></tr></table></figure>
<p>然后，我们添加一个自定义命令，该命令指定如何通过运行 <code>MakeTable</code> 来产生 <code>Table.h</code>。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the command to generate the source code</span></span><br><span class="line"><span class="comment"># 添加命令以生成源代码</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">        OUTPUT <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">        <span class="keyword">COMMAND</span> MakeTable <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">        DEPENDS MakeTable</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>接下来，我们必须让 <code>CMake</code> 知道 <code>mysqrt.cxx</code> 依赖生成的文件 <code>Table.h</code>。这是通过将生成的 <code>Table.h</code> 添加到库 <code>MathFunctions</code> 的源列表中来完成的。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the main library</span></span><br><span class="line"><span class="comment"># 添加主库</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions</span><br><span class="line">        mysqrt.cxx</span><br><span class="line">        <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>我们还必须将当前的二进制目录添加到包含目录列表中，以便 <code>mysqrt.cxx</code> 可以找到并包含 <code>Table.h</code> 。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="comment"># 说明与我们链接的任何人都需要包含当前源目录才能找到 MathFunctions.h，而我们不需要。</span></span><br><span class="line"><span class="comment"># state that we depend on Tutorial_BINARY_DIR but consumers don&#x27;t, as the</span></span><br><span class="line"><span class="comment"># Table.h include is an implementation detail</span></span><br><span class="line"><span class="comment"># state that we depend on our binary dir to find Table.h</span></span><br><span class="line"><span class="comment"># 声明我们依赖Tutorial_BINARY_DIR但消费者不依赖，因为包含Table.h是一个实现细节，我们依赖二进制目录来查找Table.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">        INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">        PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>现在，使用生成的表。首先，修改 <code>mysqrt.cxx</code> 以包含 <code>Table.h</code> 。接下来，我们可以重写 <code>mysqrt</code> 函数以使用该表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Use the table to help find an initial value &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        result = sqrtTable[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do ten iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0.1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">        result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令编译项目和生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use the table to help find an initial value </span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 12</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Computing sqrt of 12 to be 6.5</span><br><span class="line">Computing sqrt of 12 to be 4.17308</span><br><span class="line">Computing sqrt of 12 to be 3.52433</span><br><span class="line">Computing sqrt of 12 to be 3.46462</span><br><span class="line">Computing sqrt of 12 to be 3.4641</span><br><span class="line">Computing sqrt of 12 to be 3.4641</span><br><span class="line">Computing sqrt of 12 to be 3.4641</span><br><span class="line">Computing sqrt of 12 to be 3.4641</span><br><span class="line">Computing sqrt of 12 to be 3.4641</span><br><span class="line">Computing sqrt of 12 to be 3.4641</span><br><span class="line">The square root of 12 is 3.4641</span><br></pre></td></tr></table></figure>
<h2 id="生成安装程序">生成安装程序</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/build-installer">示例程序地址</a></p>
<p>接下来，假设我们想将项目分发给其他人，以便他们可以使用它。我们希望在各种平台上提供二进制和源代码分发。这与我们之前在 “安装” 示例进行的安装有些不同，在之前安装中，我们根据源代码构建的二进制文件进行安装。</p>
<p>在此示例中，我们将构建支持二进制安装和程序包管理功能的安装程序包。为此，我们将使用 <code>CPack</code> 创建平台特定的安装程序。具体来说，我们需要在顶级 <code>CMakeLists.txt</code> 文件的底部添加几行。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setup installer</span></span><br><span class="line"><span class="comment"># 设置安装程序</span></span><br><span class="line"><span class="keyword">include</span>(InstallRequiredSystemLibraries)</span><br><span class="line"><span class="keyword">set</span>(CPACK_RESOURCE_FILE_LICENSE <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION_MAJOR <span class="string">&quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION_MINOR <span class="string">&quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure>
<p>这就是全部，我们首先包含 <code>InstallRequiredSystemLibraries</code>，该模块将包含项目在当前平台所需的任何运行时库。</p>
<p>接下来，我们将一些项目信息设置给 <code>CPack</code> 变量，比如项目的许可证和版本信息。本示例中 <code>License.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a License file.</span><br></pre></td></tr></table></figure>
<p>最后，我们包含 <code>CPack</code> 模块，该模块将使用这些变量和当前系统的其他一些属性来设置安装程序。</p>
<p>在项目根目录运行命令编译项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令<strong>构建二进制发行版</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmake-build-debug</span><br><span class="line">cpack</span><br></pre></td></tr></table></figure>
<p>在项目根目录下生成了文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── ...</span><br><span class="line">├── Tutorial-1.0-Darwin.sh</span><br><span class="line">├── Tutorial-1.0-Darwin.tar.gz</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：要指定生成器，请使用 <code>-G</code> 选项。对于多配置构建，请使用 <code>-C</code> 指定配置。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpack -G ZIP -C Debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令<strong>构建源代码分发</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmake-build-debug</span><br><span class="line">cpack --config CPackSourceConfig.cmake</span><br></pre></td></tr></table></figure>
<p>在项目根目录下生成了文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── ...</span><br><span class="line">├── Tutorial-1.0-Source.tar.Z</span><br><span class="line">├── Tutorial-1.0-Source.tar.bz2</span><br><span class="line">├── Tutorial-1.0-Source.tar.gz</span><br><span class="line">├── Tutorial-1.0-Source.tar.xz</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<h2 id="添加对仪表板的支持">添加对仪表板的支持</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/support-dashboard">示例程序地址</a></p>
<p>我们已经在 “测试” 示例中为我们的项目定义了许多测试。现在，我们只需要运行这些测试并将其提交到仪表板即可。为了包括对仪表板的支持，我们在顶层 <code>CMakeLists.txt</code> 中包含了 <code>CTest</code> 模块。</p>
<p>将以下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable testing</span></span><br><span class="line"><span class="comment"># 启用测试</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable dashboard scripting</span></span><br><span class="line"><span class="comment"># 启用仪表板脚本</span></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br></pre></td></tr></table></figure>
<p><code>CTest</code> 模块将自动调用 <code>enable_testing()</code>，因此我们可以将其从 <code>CMake</code> 文件中删除。我们还需要在顶级目录中创建一个 <code>CTestConfig.cmake</code> 文件，在该文件中我们可以指定项目的名称以及提交仪表板的位置。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CTEST_PROJECT_NAME <span class="string">&quot;CMakeTutorial&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_NIGHTLY_START_TIME <span class="string">&quot;00:00:00 EST&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_METHOD <span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE <span class="string">&quot;my.cdash.org&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_LOCATION <span class="string">&quot;/submit.php?project=CMakeTutorial&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE_CDASH <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p><code>CTest</code> 将在运行时读入该文件。</p>
<p>在项目根目录运行命令编译项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -B cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行命令生成仪表板：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd cmake-build-debug</span><br><span class="line">ctest –D Experimental</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者：ctest -VV –D Experimental</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对于多配置生成器（例如Visual Studio），必须指定配置类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctest [-VV] -C Debug –D Experimental</span><br></pre></td></tr></table></figure>
<p>或者从 <code>IDE中</code> 构建 <code>Experimental</code> 目标。</p>
<p><code>ctest</code> 将构建和测试项目，并将结果提交给Kitware公共仪表板。仪表板的结果将被上传到Kitware的公共仪表板：<a href="https://my.cdash.org/index.php?project=CMakeTutorial">https://my.cdash.org/index.php?project=CMakeTutorial</a>，如下图所示：</p>
<p><img src="dashboard.jpg" alt=""></p>
<h2 id="CMake使用教程系列文章">CMake使用教程系列文章</h2>
<ul>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-1/">CMake使用教程(一)</a>
<ul>
<li>基础项目</li>
<li>添加版本号和配置头文件</li>
<li>指定C++标准</li>
<li>添加库</li>
<li>提供选项</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-2/">CMake使用教程(二)</a>
<ul>
<li>添加“库”的使用要求</li>
<li>安装</li>
<li>测试</li>
<li>系统自检</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-3/">CMake使用教程(三)</a>
<ul>
<li>指定编译定义</li>
<li>添加自定义命令和生成的文件</li>
<li>生成安装程序</li>
<li>添加对仪表板的支持</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-4/">CMake使用教程(四)</a>
<ul>
<li>混合静态和共享</li>
<li>添加生成器表达式</li>
<li>添加导出配置</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>cmake-tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake使用教程(四)</title>
    <url>/2019/11/18/cmake-tutorial-4/</url>
    <content><![CDATA[<p><code>CMake</code> 是一种跨平台的免费开源软件工具，用于使用与编译器无关的方法来管理软件的构建过程。在 <code>Android Studio</code> 上进行 <code>NDK</code> 开发默认就是使用 <code>CMake</code> 管理 <code>C/C++</code> 代码，因此在学习 <code>NDK</code> 之前最好对 <code>CMake</code> 有一定的了解。</p>
<span id="more"></span>
<p>本文主要以翻译 <code>CMake</code> 的<a href="https://cmake.org/cmake/help/v3.16/guide/tutorial/index.html">官方教程文档</a>为主，加上自己的一些理解，该教程涵盖了 <code>CMake</code> 的常见使用场景。由于能力有限，翻译部分采用机翻+人工校对，翻译有问题的地方，说声抱歉。</p>
<p>开发环境：</p>
<ul>
<li>macOS 10.14.6</li>
<li>CMake 3.15.1</li>
<li>CLion 2018.2.4</li>
</ul>
<h2 id="混合静态和共享">混合静态和共享</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/mixing-static-and-shared">示例程序地址</a></p>
<p>在本节中，我们将展示如何使用 <code>BUILD_SHARED_LIBS</code> 变量来控制 <code>add_library</code> 的默认行为，并允许控制构建没有显式类型 <code>(STATIC/SHARED/MODULE/OBJECT)</code> 的库。</p>
<p>为此，我们需要将 <code>BUILD_SHARED_LIBS</code> 添加到顶级 <code>CMakeLists.txt</code>。我们使用 <code>option</code> 命令，因为它允许用户有选择地选择该值是 <code>On</code> 还是 <code>Off</code>。</p>
<p>接下来，我们将重构 <code>MathFunctions</code> 使其成为使用 <code>mysqrt</code> 或 <code>sqrt</code> 封装的真实库，而不是要求调用代码执行此逻辑。这也意味着 <code>USE_MYMATH</code> 将不会控制构建 <code>MathFuctions</code>，而是将控制此库的行为。</p>
<p>第一步是将顶级 <code>CMakeLists.txt</code> 的开始部分更新为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置运行此配置文件所需的CMake最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="comment"># 设置项目名称和版本</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="comment"># 指定C ++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># control where the static and shared libraries are built so that on windows</span></span><br><span class="line"><span class="comment"># we don&#x27;t need to tinker with the path to run the executable</span></span><br><span class="line"><span class="comment"># 控制静态和共享库的构建位置，以便在Windows上我们无需修改运行可执行文件的路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build using shared libraries&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass the version number only</span></span><br><span class="line"><span class="comment"># 配置头文件且仅传递版本号</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="comment"># 添加MathFunctions库</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="comment"># 添加一个可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="comment"># 将二进制目录添加到包含文件的搜索路径中，以便我们找到TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>现在我们将始终使用 <code>MathFunctions</code> 库，我们需要更新该库的逻辑。因此，在 <code>MathFunctions/CMakeLists.txt</code> 中，我们需要创建一个 <code>SqrtLibrary</code> ，当启用 <code> USE_MYMATH</code> 时有条件地对其进行构建。现在，由于这是一个教程，我们将明确要求 <code>SqrtLibrary</code> 是静态构建的。</p>
<p>最终结果是 <code>MathFunctions/CMakeLists.txt</code> 应该如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the library that runs</span></span><br><span class="line"><span class="comment"># 添加运行时库</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions MathFunctions.cxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="comment"># 说明与我们链接的任何人都需要包括当前源目录才能找到MathFunctions.h，而我们不需要。</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">        INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line"><span class="comment"># 我们是否使用自己的数学函数</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(MathFunctions PRIVATE <span class="string">&quot;USE_MYMATH&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># first we add the executable that generates the table</span></span><br><span class="line">    <span class="comment"># 首先，我们添加生成表的可执行文件</span></span><br><span class="line">    <span class="keyword">add_executable</span>(MakeTable MakeTable.cxx)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add the command to generate the source code</span></span><br><span class="line">    <span class="comment"># 添加命令以生成源代码</span></span><br><span class="line">    <span class="keyword">add_custom_command</span>(</span><br><span class="line">            OUTPUT <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">            <span class="keyword">COMMAND</span> MakeTable <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">            DEPENDS MakeTable</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># library that just does sqrt</span></span><br><span class="line">    <span class="comment"># 只包含sqrt的库</span></span><br><span class="line">    <span class="keyword">add_library</span>(SqrtLibrary STATIC</span><br><span class="line">            mysqrt.cxx</span><br><span class="line">            <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># state that we depend on our binary dir to find Table.h</span></span><br><span class="line">    <span class="comment"># 声明我们依靠二进制目录找到Table.h</span></span><br><span class="line">    <span class="keyword">target_include_directories</span>(SqrtLibrary PRIVATE</span><br><span class="line">            <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE SqrtLibrary)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the symbol stating we are using the declspec(dllexport) when</span></span><br><span class="line"><span class="comment"># building on windows</span></span><br><span class="line"><span class="comment"># 定义标记在Windows上构建时使用declspec(dllexport)</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(MathFunctions PRIVATE <span class="string">&quot;EXPORTING_MYMATH&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># install rules</span></span><br><span class="line"><span class="comment"># 安装规则</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>接下来在 <code>MathFunctions</code> 文件目录下， 新建一个 <code>mysqrt.h</code> 文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mathfunctions &#123;</span><br><span class="line">    <span class="keyword">namespace</span> detail &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在 <code>MathFunctions</code> 文件目录下， 新建一个 <code>MathFunctions.cxx</code> 文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&quot;mysqrt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">        <span class="keyword">return</span> detail::<span class="built_in">mysqrt</span>(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，更新 <code>MathFunctions/mysqrt.cxx</code> 以使用 <code>mathfunctions</code> 和 <code>detail</code> 命名空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mysqrt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include the generated table</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Table.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions &#123;</span><br><span class="line">    <span class="keyword">namespace</span> detail &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> result = x;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Use the table to help find an initial value &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                result = sqrtTable[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do ten iterations</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = <span class="number">0.1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">                result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们还需要在 <code>tutorial.cxx</code> 中进行一些更改，以使其不再使用 <code>USE_MYMATH</code>：</p>
<ol>
<li>始终包含 <code>MathFunctions.h</code></li>
<li>始终使用 <code>mathfunctions::sqrt</code></li>
<li>不包含 <code>cmath</code></li>
</ol>
<p>移除 <code>TutorialConfig.h.in</code> 中关于 <code>USE_MYMATH</code> 的定义，最后，更新 <code>MathFunctions/MathFunctions.h</code> 以使用 <code>dll</code> 导出定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined(EXPORTING_MYMATH)</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> DECLSPEC __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> DECLSPEC __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// non windows</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> DECLSPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> DECLSPEC <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，如果您构建了所有内容，则会注意到链接会失败，因为我们将没有位置的静态库代码库与具有位置的代码库相结合。解决方案是无论构建类型如何，都将 <code>SqrtLibrary</code> 的 <code>POSITION_INDEPENDENT_CODE</code> 目标属性显式设置为 <code>True</code>。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state that SqrtLibrary need PIC when the default is shared libraries</span></span><br><span class="line"><span class="comment"># 声明默认为共享库时，SqrtLibrary需要PIC</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(SqrtLibrary PROPERTIES</span><br><span class="line">        POSITION_INDEPENDENT_CODE <span class="variable">$&#123;BUILD_SHARED_LIBS&#125;</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line"><span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE SqrtLibrary)</span><br></pre></td></tr></table></figure>
<p>使用 <code>cmake-gui</code> 构建项目，勾选 <code>BUILD_SHARED_LIBS</code></p>
<p>在项目根目录运行命令生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use the table to help find an initial value </span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<p>使用 <code>cmake-gui</code> 重新构建项目，取消勾选 <code>BUILD_SHARED_LIBS</code></p>
<p>在项目根目录运行命令生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build cmake-build-debug</span><br></pre></td></tr></table></figure>
<p>在项目根目录运行生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake-build-debug/Tutorial 2</span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use the table to help find an initial value </span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>
<h2 id="添加生成器表达式">添加生成器表达式</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/add-generator-expressions">示例程序地址</a></p>
<p>在构建系统生成期间会评估生成器表达式，以生成特定于每个构建配置的信息。</p>
<p>在许多目标属性的上下文中允许使用生成器表达式，例如 <code>LINK_LIBRARIES</code>、<code>INCLUDE_DIRECTORIES</code>、 <code>COMPILE_DEFINITIONS</code> 等。当使用命令填充这些属性时，也可以使用它们，例如 <code>target_link_libraries()</code>、<code>target_include_directories()</code>、<code>target_compile_definitions()</code>等。</p>
<p>生成器表达式可用于启用条件链接、编译时使用的条件定义、条件包含目录等。这些条件可以基于构建配置、目标属性、平台信息或任何其他可查询信息。</p>
<p>生成器表达式有不同类型，包括逻辑，信息和输出表达式。</p>
<p>逻辑表达式用于创建条件输出，基本的表达式是0和1表达式，即布尔表达式。<code>$&lt;0:…&gt;</code>  代表冒号前的条件为假，表达式的结果为空字符串。 <code>$&lt;1:…&gt;</code> 代表冒号前的条件为真，表达式的结果为“…”的内容</p>
<p>生成器表达式的一个常见用法是有条件地添加编译器标志，例如语言级别或警告标志。一个好的模式是将此信息与允许传播此信息的 <code>INTERFACE</code> 目标相关联。让我们开始构建 <code>INTERFACE</code> 目标，并指定所需的 <code>C++</code> 标准级别11，而不是使用 <code>CMACHYCXXY</code> 标准。</p>
<p>所以下面的代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="comment"># 指定C ++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>将被替换为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(tutorial_compiler_flags INTERFACE)</span><br><span class="line"><span class="keyword">target_compile_features</span>(tutorial_compiler_flags INTERFACE cxx_std_11)</span><br></pre></td></tr></table></figure>
<p>接下来，我们为项目添加所需的编译器警告标志。由于警告标志根据编译器的不同而不同，因此我们使用 <code>COMPILE_LANG_AND_ID</code> 生成器表达式来控制在给定一种语言和一组编译器 <code>ID</code> 的情况下应应用的标志，如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add compiler warning flags just when building this project via</span></span><br><span class="line"><span class="comment"># the BUILD_INTERFACE genex</span></span><br><span class="line"><span class="comment"># 仅当通过BUILD_INTERFACE生成此项目时添加编译器警告标志</span></span><br><span class="line"><span class="keyword">set</span>(gcc_like_cxx <span class="string">&quot;$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(msvc_cxx <span class="string">&quot;$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">target_compile_options</span>(tutorial_compiler_flags INTERFACE</span><br><span class="line">        <span class="string">&quot;$&lt;$&#123;gcc_like_cxx&#125;:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;&quot;</span></span><br><span class="line">        <span class="string">&quot;$&lt;$&#123;msvc_cxx&#125;:$&lt;BUILD_INTERFACE:-W3&gt;&gt;&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>我们可以看到警告标志封装在 <code>BUILD_INTERFACE</code> 条件内。这样做是为了让已安装项目的使用者不会继承我们的警告标志。</p>
<p>修改 <code>MathFunctions/CMakeLists.txt</code> 文件，使所有的目标都增加一个调用 <code>tutorial_compiler_flags</code> 的  <code>target_link_libraries</code>。</p>
<h2 id="添加导出配置">添加导出配置</h2>
<p><a href="https://github.com/TaylorKunZhang/cmake-tutorial/tree/master/add-export-configuration">示例程序地址</a></p>
<p>在本教程的 “安装” 一节，我们增加了 <code>CMake</code> 安装库和项目头的能力。在 &quot;生成安装程序“ 一节，我们添加了打包此信息的功能，以便将其分发给其他人。</p>
<p>下一步是添加必要的信息，以便其他 <code>CMake</code> 项目可以使用我们的项目，无论是构建目录、本地安装还是打包。</p>
<p>第一步是更新我们的 <code>install(TARGETS)</code> 命令，不仅要指定 <code>DESTINATION</code>，还要指定 <code>EXPORT</code>。<code>EXPORT</code> 关键字将生成并安装一个CMake文件，该文件包含用于从安装树中导入 <code>install</code> 命令中列出的所有目标的代码。通过更新 <code>MathFunctions/CMakeLists.txt</code> 中的 <code>install</code> 命令，显式导出 <code>MathFunctions</code>库，如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install rules</span></span><br><span class="line"><span class="comment"># 安装规则</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions tutorial_compiler_flags</span><br><span class="line">        DESTINATION lib</span><br><span class="line">        <span class="keyword">EXPORT</span> MathFunctionsTargets)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们已经导出了 <code>MathFunctions</code>，我们还需要显式安装生成的 <code>MathFunctionsTargets.cmake</code> 文件。这是通过将以下内容添加到顶级 <code>CMakeLists.txt</code> 的底部来完成的：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install the configuration targets</span></span><br><span class="line"><span class="comment"># 安装配置目标</span></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">        <span class="keyword">FILE</span> MathFunctionsTargets.cmake</span><br><span class="line">        DESTINATION lib/cmake/MathFunctions</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>此时，您应该尝试运行 <code>CMake</code>。如果一切设置正确，您将看到 <code>CMake</code> 将生成如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Target &quot;MathFunctions&quot; INTERFACE_INCLUDE_DIRECTORIES property contains</span><br><span class="line">path:</span><br><span class="line"></span><br><span class="line">  &quot;&#x2F;Users&#x2F;robert&#x2F;Documents&#x2F;CMakeClass&#x2F;Tutorial&#x2F;Step11&#x2F;MathFunctions&quot;</span><br><span class="line"></span><br><span class="line">which is prefixed in the source directory.</span><br></pre></td></tr></table></figure>
<p><code>CMake</code> 想说的是，在生成导出信息的过程中，它将导出一个与当前机器有内在联系的路径，并且在其他机器上无效。解决方案是更新 <code>MathFunctions</code> 的 <code>target_include_directories</code>，让 <code>CMake</code> 理解在从生成目录和安装/打包中使用时需要不同的接口位置。这意味着将 <code>MathFunctions</code> 调用的 <code>target_include_directories</code> 转换为如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="comment"># 说明与我们链接的任何人都需要包括当前源目录才能找到MathFunctions.h，而我们不需要。</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">        INTERFACE</span><br><span class="line">        $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;</span><br><span class="line">        $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>更新后，我们可以重新运行 <code>CMake</code> 并查看是否不再发出警告。</p>
<p>至此，我们已经正确地包装了 <code>CMake</code> 所需的目标信息，但仍然需要生成 <code>MathFunctionsConfig.cmake</code>，以便 <code>CMake find_package</code> 命令可以找到我们的项目。因此，我们将添加新文件 <code>Config.cmake.in</code> 到项目的顶层，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PACKAGE_INIT@</span><br><span class="line"></span><br><span class="line">include ( &quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;MathFunctionsTargets.cmake&quot; )</span><br></pre></td></tr></table></figure>
<p>然后，要正确配置和安装该文件，请在顶级 <code>CMakeLists</code> 的底部添加以下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install the configuration targets</span></span><br><span class="line"><span class="comment"># 安装配置目标</span></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">        <span class="keyword">FILE</span> MathFunctionsTargets.cmake</span><br><span class="line">        DESTINATION lib/cmake/MathFunctions</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br><span class="line"><span class="comment"># generate the config file that is includes the exports</span></span><br><span class="line"><span class="comment"># 生成包含导出的配置文件</span></span><br><span class="line">configure_package_config_file(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Config.cmake.in</span><br><span class="line">        <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfig.cmake&quot;</span></span><br><span class="line">        INSTALL_DESTINATION <span class="string">&quot;lib/cmake/example&quot;</span></span><br><span class="line">        NO_SET_AND_CHECK_MACRO</span><br><span class="line">        NO_CHECK_REQUIRED_COMPONENTS_MACRO</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># generate the version file for the config file</span></span><br><span class="line"><span class="comment"># 生成配置文件的版本文件</span></span><br><span class="line">write_basic_package_version_file(</span><br><span class="line">        <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfigVersion.cmake&quot;</span></span><br><span class="line">        VERSION <span class="string">&quot;$&#123;Tutorial_VERSION_MAJOR&#125;.$&#123;Tutorial_VERSION_MINOR&#125;&quot;</span></span><br><span class="line">        COMPATIBILITY AnyNewerVersion</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># install the configuration file</span></span><br><span class="line"><span class="comment"># 安装配置文件</span></span><br><span class="line"><span class="keyword">install</span>(FILES</span><br><span class="line">        <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfig.cmake</span><br><span class="line">        DESTINATION lib/cmake/MathFunctions</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>至此，我们为项目生成了可重定位的 <code>CMake</code> 配置，可以在安装或打包项目后使用它。如果我们也希望从构建目录中使用我们的项目，则只需将以下内容添加到顶级 <code>CMakeLists</code> 的底部：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generate the export targets for the build tree</span></span><br><span class="line"><span class="comment"># needs to be after the install(TARGETS ) command</span></span><br><span class="line"><span class="comment"># 在install(TARGETS)命令之后生成生成树的导出目标</span></span><br><span class="line"><span class="keyword">export</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">        <span class="keyword">FILE</span> <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsTargets.cmake&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>通过此导出调用我们将生成一个 <code>Targets.cmake</code>，允许在构建目录中配置的 <code>MathFunctionsConfig.cmake</code> 由其他项目使用，而无需安装它。</p>
<h2 id="CMake使用教程系列文章">CMake使用教程系列文章</h2>
<ul>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-1/">CMake使用教程(一)</a>
<ul>
<li>基础项目</li>
<li>添加版本号和配置头文件</li>
<li>指定C++标准</li>
<li>添加库</li>
<li>提供选项</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-2/">CMake使用教程(二)</a>
<ul>
<li>添加“库”的使用要求</li>
<li>安装</li>
<li>测试</li>
<li>系统自检</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-3/">CMake使用教程(三)</a>
<ul>
<li>指定编译定义</li>
<li>添加自定义命令和生成的文件</li>
<li>生成安装程序</li>
<li>添加对仪表板的支持</li>
</ul>
</li>
<li><a href="https://blog.taylorzhang.cc/2019/11/18/cmake-tutorial-4/">CMake使用教程(四)</a>
<ul>
<li>混合静态和共享</li>
<li>添加生成器表达式</li>
<li>添加导出配置</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>cmake-tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment可见性及懒加载终极解决方案</title>
    <url>/2021/03/02/fragment-visibility/</url>
    <content><![CDATA[<p>Fragment 有很多种使用方法，官方并没有提供一个统一的 api 来处理 Fragment 的可见性判断和回调，导致在不同的使用场景下需要使用不同的方法来判断 Fragment 的可见性。网上已经有很多讲 Fragment 可见性的文章，但是大部分文章覆盖的使用场景不够全面，有些文章的用法也过时了，因此本人梳理了当前 Fragment 的各种使用场景，提供了一个统一的 api 来处理 Fragment 的可见性。</p>
<span id="more"></span>
<h2 id="一般使用场景">一般使用场景</h2>
<h3 id="在Activity中直接使用">在Activity中直接使用</h3>
<p>在 xml 文件中声明 Fragment，或者在代码中通过 FragmentTransaction 的 add 或 replace 动态载入 Fragment。这两种情况下都只要监听 Fragment 的 onResume 和 onPause 方法就能判断 Fragment 的可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    determineFragmentVisible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line"></span><br><span class="line">    determineFragmentInvisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用show和hide控制显示和隐藏">使用show和hide控制显示和隐藏</h3>
<blockquote>
<p>Google 在 <code>androidx.fragment 1.2.0</code> 中新增了一个 FragmentContainerView，用来替代 FlameLayout 做为 Fragment 的容器，在下文中将使用 FragmentContainerView 作为 Fragment 的容器。</p>
</blockquote>
<h4 id="老的用法">老的用法</h4>
<p>通过 FragmentTransaction 的 add 将 Fragment 添加到 FragmentManager 后，Fragment 的生命周期会跟随绑定的 Activity 或父 Fragment 走到 onResume，这个时候，只要所依附的 Activity 或父 Fragment 的生命周期不发生变化，通过 FragmentTransaction 的 show 和 hide 方法控制 Fragment 的显示和隐藏并不会改变 Fragment 的生命周期，这个时候需要监听 onHiddenChanged 判断 Fragment 的可见性。</p>
<p>一般情况下，将 Fragment add 到 FragmentManager 的过程是在 Activity 中的 onCreate 回调中进行的，第一次回调 onHiddenChanged 是在 Fragment 回调 onCreateView 之前。如果需要在 Fragment 第一次可见的时候进行 UI 操作，就会出错，为了避免出错，需要结合 Fragment 的 onResume 和 onPause 判断 Fragment 的可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHiddenChanged</span><span class="params">(hidden: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onHiddenChanged(hidden)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hidden) &#123;</span><br><span class="line">        determineFragmentInvisible()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        determineFragmentVisible()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    determineFragmentVisible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line"></span><br><span class="line">    determineFragmentInvisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AndroidX用法">AndroidX用法</h4>
<p>调用了 hide 后，接着调用 <code>setMaxLifecycle(fragment, Lifecycle.State.STARTED)</code>，Fragment 生命周期会走到 onPause。调用 show 方法后，接着调用 <code>setMaxLifecycle(fragment, Lifecycle.State.RESUMED)</code>，Fragment 生命周期会走到 onPause。这样只要监听 Fragment 的 onResume 和 onPause 方法就能判断 Fragment 的可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    determineFragmentVisible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line"></span><br><span class="line">    determineFragmentInvisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在ViewPager中使用">在ViewPager中使用</h3>
<h4 id="老的用法-2">老的用法</h4>
<p>在 support 和  <code>androidx.fragment 1.0.0</code>，通过监听 setUserVisibleHint 判断Fragment 的可见性。如果将 Fragment add 到 FragmentManager 的过程是在 Activity 中的 onCreate 回调中进行的，第一次回调 setUserVisibleHint 也是在 Fragment 回调 onCreateView 之前，也需要结合 Fragment 的 onResume 和 onPause 判断 Fragment 的可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUserVisibleHint</span><span class="params">(isVisibleToUser: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">        determineFragmentVisible()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        determineFragmentInvisible()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    determineFragmentVisible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line"></span><br><span class="line">    determineFragmentInvisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AndroidX用法-2">AndroidX用法</h4>
<p>谷歌从 <code>androidx.fragment 1.1.0</code> 中开始，对 FragmentPagerAdapter 和 FragmentStatePagerAdapter 进行了调整，支持使用 setMaxLifecycle 控制 Fragment 的生命周期，只需要创建 Adpter 的时候， Behavior 选择 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">    Fragment fragment = (Fragment)object;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                ...</span><br><span class="line">                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只要监听 Fragment 的 onResume 和 onPause 方法就能判断 Fragment 的可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    determineFragmentVisible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line"></span><br><span class="line">    determineFragmentInvisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在ViewPager2中使用">在ViewPager2中使用</h3>
<p>在 ViewPager2 中使用 Fragment 时，使用的适配器是 FragmentStateAdapter，FragmentStateAdapter 内部使用 FragmentMaxLifecycleEnforcer ，FragmentMaxLifecycleEnforcer 也是通过 setMaxLifecycle 控制 Fragment 的生命周期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentStateAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mFragmentMaxLifecycleEnforcer = <span class="keyword">new</span> FragmentMaxLifecycleEnforcer();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromRecyclerView</span><span class="params">(<span class="meta">@NonNull</span> RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mFragmentMaxLifecycleEnforcer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FragmentMaxLifecycleEnforcer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateFragmentMaxLifecycle</span><span class="params">(<span class="keyword">boolean</span> dataSetChanged)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ix = <span class="number">0</span>; ix &lt; mFragments.size(); ix++) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (itemId != mPrimaryItemId) &#123;</span><br><span class="line">                    transaction.setMaxLifecycle(fragment, STARTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    toResume = fragment; <span class="comment">// itemId map key, so only one can match the predicate</span></span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (toResume != <span class="keyword">null</span>) &#123; <span class="comment">// in case the Fragment wasn&#x27;t added yet</span></span><br><span class="line">                transaction.setMaxLifecycle(toResume, RESUMED);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只要监听 Fragment 的 onResume 和 onPause 方法就能判断 Fragment 的可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    determineFragmentVisible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line"></span><br><span class="line">    determineFragmentInvisible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体实现">具体实现</h3>
<p>在 <code>IFragmentVisibility</code> 中定义 Fragment 可见性相关方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFragmentVisibility</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fragment可见时调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onVisible</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fragment不可见时调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onInvisible</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fragment第一次可见时调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onVisibleFirst</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fragment可见时（第一次除外）调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onVisibleExceptFirst</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fragment当前是否对用户可见</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isVisibleToUser</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Fragment可见">Fragment可见</h4>
<p>Fragment 可见受到几个因素影响：Fragment 是否处于 RESUMED 状态、Fragment 是否显示、Fragment Hint 是否对用户可见，判断Fragment可见性可能会被连续调用多次，如果当前已经对用户可见，则不进行判断可见性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fragment当前是否对用户可见。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mIsFragmentVisible = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment当前是否是第一次对用户可见。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mIsFragmentVisibleFirst = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineFragmentVisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isResumed &amp;&amp; !isHidden &amp;&amp; userVisibleHint &amp;&amp; !mIsFragmentVisible) &#123;</span><br><span class="line">        mIsFragmentVisible = <span class="literal">true</span></span><br><span class="line">        onVisible()</span><br><span class="line">        <span class="keyword">if</span> (mIsFragmentVisibleFirst) &#123;</span><br><span class="line">            mIsFragmentVisibleFirst = <span class="literal">false</span></span><br><span class="line">            onVisibleFirst()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onVisibleExceptFirst()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Fragment不可见">Fragment不可见</h4>
<p>当 Fragment 处于可见状态，调用一次 determineFragmentInvisible 方法，Fragment 就变成不可见了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineFragmentInvisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsFragmentVisible) &#123;</span><br><span class="line">        mIsFragmentVisible = <span class="literal">false</span></span><br><span class="line">        onInvisible()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fragment嵌套">Fragment嵌套</h2>
<p><img src="nested-fragment.png" alt=""></p>
<h3 id="老的用法-3">老的用法</h3>
<p>从日志中可以看到，Fragment-1 和 Fragment-1-1 处于可见状态，但是奇怪的是 Fragment-2-1 也处于可见状态，这不符合逻辑，判断可见性逻辑还有待优化的地方。</p>
<p><img src="nested-old-way-1.png" alt=""></p>
<p>分析日志可知，所有的 Fragment 生命周期都走到了onResume，但是 Fragment-2、Fragment-1-2、Fragment-2-2 因为 <code>isHidden = true</code>，判断出是不可见状态。Fragment-2-1 是 <code>isHidden = false</code>，但是 Fragment-2 是 <code>isHidden = true</code>，从逻辑上父 Fragment 不可见，子 Fragment 也应该不可见。所以在判断 Fragment 是否可见的时候，还要考虑父 Fragment 是否可见（如果存在父 Fragment）。</p>
<p>当从 Fragment-1 切换到 Fragment-2 后，可以看到，Fragment-1 不可见，Fragment-2 可见，但是本应该不可见的 Fragment-1-1 还是可见，本应该可见的 Fragment-2-1 还是不可见，说明判断可见性逻辑还有待优化的地方。</p>
<p><img src="nested-old-way-2.png" alt=""></p>
<p>从 Fragment-1 切换到 Fragment-2，这两者的 onHiddenChanged 被调用了，所以它们的可见性发生了变化。Fragment-1-1 和 Fragment-2-1 没有任何操作，但是它们的可见性也应该随着父Fragment 可见性发生变化而变化，所以应该在父 Fragment 可见性变化的时候重新判断一次子 Fragment 的可见性。</p>
<h3 id="AndroidX用法-3">AndroidX用法</h3>
<p>全部使用 setMaxLifecycle 控制 Fragment 生命周期，可以看到 Fragment 的可见性判断是正确的。</p>
<p><img src="nested-new-way-1.png" alt=""></p>
<p>从 Fragment-1 切换到 Fragment-2，可见性判断还是正确的。</p>
<p><img src="nested-new-way-2.png" alt=""></p>
<p>子 Fragment 的生命周期会根据所绑定的 Activity 或父 Fragment 的生命周期变化而变化，setMaxLifecycle 改变了父 Fragment 的生命周期，子 Fragment 的生命周期自然就跟着变化了。所以，仅监听 Fragment 的 onResume 和 onPause 就能判断 Fragment 的可见性，不需要调整判断逻辑。</p>
<h3 id="具体实现-2">具体实现</h3>
<p>在 determineFragmentVisible 中增加判断父 Fragment 是否可见的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineFragmentVisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> parent = parentFragment</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span> &amp;&amp; parent <span class="keyword">is</span> VisibilityFragment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent.isVisibleToUser()) &#123;</span><br><span class="line">            <span class="comment">// 父Fragment不可见，子Fragment也一定不可见</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 determineFragmentVisible 和 determineFragmentInvisible 增加判断子 Fragment 的可见性代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineFragmentVisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isResumed &amp;&amp; !isHidden &amp;&amp; userVisibleHint &amp;&amp; !mIsFragmentVisible) &#123;</span><br><span class="line">        ...</span><br><span class="line">        determineChildFragmentVisible()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineFragmentInvisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsFragmentVisible) &#123;</span><br><span class="line">        ...</span><br><span class="line">        determineChildFragmentInvisible()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineChildFragmentVisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    childFragmentManager.fragments.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it <span class="keyword">is</span> VisibilityFragment) &#123;</span><br><span class="line">            it.determineFragmentVisible()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">determineChildFragmentInvisible</span><span class="params">()</span></span> &#123;</span><br><span class="line">    childFragmentManager.fragments.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it <span class="keyword">is</span> VisibilityFragment) &#123;</span><br><span class="line">            it.determineFragmentInvisible()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒加载">懒加载</h2>
<p>在实现了上述功能后，对于需要懒加载功能的 Fragment，只需要重写 onVisibleFirst，在里面加载数据就可以了。</p>
<h2 id="总结">总结</h2>
<p>对于全部使用 setMaxLifecycle 控制 Fragment 生命周期的代码，Fragment 的可见性判断相对比较简单，只要监听 Fragment 的 onResume 和 onPause 方法就能判断 Fragment 的可见性。</p>
<p>对于老的用法或者老的用法和 setMaxLifecycle 混用的代码，Fragment 可见性判断不仅要考虑使用方式，也要考虑父 Fragment 的可见性，同时自身可见性改变的时候，也要主动调用子 Fragment 判断可见性的代码。</p>
<h2 id="项目地址">项目地址</h2>
<p><a href="https://github.com/TaylorKunZhang/fragment-visibility">fragment-visibility</a>，觉得用起来很爽的，请不要吝啬你的 Star ！</p>
<h2 id="参考">参考</h2>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0422/7863.html">如何判断Fragment是否对用户可见</a></p>
<p><a href="https://juejin.im/post/5cdb7c15f265da036c57ac66">Fragment新功能，setMaxLifecycle了解一下</a></p>
<p><a href="https://juejin.cn/post/6844904050698223624">Androidx 下 Fragment 懒加载的新实现</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>Android优雅处理重复点击</title>
    <url>/2021/03/20/single-click/</url>
    <content><![CDATA[<p>一般手机上的 Android App，主要的交互方式是点击。用户在点击后，App 可能做出在页面内更新 UI、新开一个页面或者发起网络请求等操作。Android 系统本身没有对重复点击做处理，如果用户在短时间内多次点击，则可能出现新开多个页面或者重复发起网络请求等问题。因此，需要对重复点击有影响的地方，增加处理重复点击的代码。</p>
<span id="more"></span>
<h2 id="之前的处理方式">之前的处理方式</h2>
<p>之前在项目中使用的是 RxJava 的方案，利用第三方库 <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> 实现了防止重复点击：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onSingleClick</span><span class="params">(interval: <span class="type">Long</span> = <span class="number">1000</span>L, listener: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    RxView.clicks(<span class="keyword">this</span>)</span><br><span class="line">        .throttleFirst(interval, TimeUnit.MILLISECONDS)</span><br><span class="line">        .subscribe(&#123;</span><br><span class="line">            listener.invoke(<span class="keyword">this</span>)</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            LogUtil.printStackTrace(it)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样有一个问题，比如使用两个手指同时点击两个不同的按钮，按钮的功能都是新开页面，那么有可能会新开两个页面。因为 Rxjava 这种方式是针对单个控件实现防止重复点击，不是多个控件。</p>
<h2 id="现在的处理方式">现在的处理方式</h2>
<p>现在使用的是时间判断，在时间范围内只响应一次点击，通过将上次单击时间保存到 Activity Window 中的 decorView 里，实现一个 Activity 中所有的 View 共用一个上次单击时间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onSingleClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    interval: <span class="type">Int</span> = SingleClickUtil.singleClickInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    isShareSingleClick: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    listener: (<span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">val</span> target = <span class="keyword">if</span> (isShareSingleClick) getActivity(<span class="keyword">this</span>)?.window?.decorView ?: <span class="keyword">this</span> <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> millis = target.getTag(R.id.single_click_tag_last_single_click_millis) <span class="keyword">as</span>? <span class="built_in">Long</span> ?: <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (SystemClock.uptimeMillis() - millis &gt;= interval) &#123;</span><br><span class="line">            target.setTag(</span><br><span class="line">                R.id.single_click_tag_last_single_click_millis, SystemClock.uptimeMillis()</span><br><span class="line">            )</span><br><span class="line">            listener.invoke(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getActivity</span><span class="params">(view: <span class="type">View</span>)</span></span>: Activity? &#123;</span><br><span class="line">    <span class="keyword">var</span> context = view.context</span><br><span class="line">    <span class="keyword">while</span> (context <span class="keyword">is</span> ContextWrapper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">is</span> Activity) &#123;</span><br><span class="line">            <span class="keyword">return</span> context</span><br><span class="line">        &#125;</span><br><span class="line">        context = context.baseContext</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 isShareSingleClick 的默认值是 true，表示该控件和同一个 Activity 中其他控件共用一个上次单击时间，也可以手动改成 false，表示该控件自己独享一个上次单击时间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mBinding.btn1.onSingleClick &#123;</span><br><span class="line">    <span class="comment">// 处理单次点击</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mBinding.btn2.onSingleClick(interval = <span class="number">2000</span>, isShareSingleClick = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理单次点击</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他场景处理重复点击">其他场景处理重复点击</h2>
<h3 id="间接设置点击">间接设置点击</h3>
<p>除了直接在 View 上设置的点击监听外，其他间接设置点击的地方也存在需要处理重复点击的场景，比如说富文本和列表。</p>
<p>为此将判断是否触发单次点击的代码抽离出来，单独作为一个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onSingleClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    interval: <span class="type">Int</span> = SingleClickUtil.singleClickInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    isShareSingleClick: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    listener: (<span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    setOnClickListener &#123; determineTriggerSingleClick(interval, isShareSingleClick, listener) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">determineTriggerSingleClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    interval: <span class="type">Int</span> = SingleClickUtil.singleClickInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    isShareSingleClick: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    listener: (<span class="type">View</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>直接在点击监听回调中调用 determineTriggerSingleClick 判断是否触发单次点击</strong>。下面拿富文本和列表举例。</p>
<h4 id="富文本">富文本</h4>
<p>继承 ClickableSpan，在 onClick 回调中判断是否触发单次点击：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> SpannableStringBuilder.<span class="title">onSingleClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    listener: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    isShareSingleClick: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SpannableStringBuilder = inSpans(</span><br><span class="line">    <span class="keyword">object</span> : ClickableSpan() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(widget: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            widget.determineTriggerSingleClick(interval, isShareSingleClick, listener)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    builderAction = builderAction</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样会有一个问题， onClick 回调中的 widget，就是设置富文本的控件，也就是说如果富文本存在多个单次点击的地方， 就算 isShareSingleClick 值为 false，这些单次点击还是会共用设置富文本控件的上次单击时间。</p>
<p>因此，这里需要特殊处理，在 isShareSingleClick 为 false 的时候，创建一个假的 View 来触发单击事件，这样富文本中多个单次点击 isShareSingleClick 为 false 的地方都有一个自己的假的 View 来独享上次单击时间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleClickableSpan</span></span>(</span><br><span class="line">    ...</span><br><span class="line">) : ClickableSpan() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFakeView: View? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(widget: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShareSingleClick) &#123;</span><br><span class="line">            widget</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFakeView == <span class="literal">null</span>) &#123;</span><br><span class="line">                mFakeView = View(widget.context)</span><br><span class="line">            &#125;</span><br><span class="line">            mFakeView!!</span><br><span class="line">        &#125;.determineTriggerSingleClick(interval, isShareSingleClick, listener)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置富文本的地方，使用设置 onSingleClick 实现单次点击：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mBinding.tvText.movementMethod = LinkMovementMethod.getInstance()</span><br><span class="line">mBinding.tvText.highlightColor = Color.TRANSPARENT</span><br><span class="line">mBinding.tvText.text = buildSpannedString &#123;</span><br><span class="line">    append(<span class="string">&quot;normalText&quot;</span>)</span><br><span class="line">    onSingleClick(&#123;</span><br><span class="line">        <span class="comment">// 处理单次点击</span></span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        color(Color.GREEN) &#123; append(<span class="string">&quot;clickText&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="列表">列表</h4>
<p>列表使用 RecyclerView 控件，适配器使用第三方库 <a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper">BaseRecyclerViewAdapterHelper</a>。</p>
<p>Item 点击：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">adapter.setOnItemClickListener &#123; _, view, _ -&gt;</span><br><span class="line">    view.determineTriggerSingleClick &#123;</span><br><span class="line">        <span class="comment">// 处理单次点击</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Item Child 点击：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">adapter.addChildClickViewIds(R.id.btn1, R.id.btn2)</span><br><span class="line">adapter.setOnItemChildClickListener &#123; _, view, _ -&gt;</span><br><span class="line">    <span class="keyword">when</span> (view.id) &#123;</span><br><span class="line">        R.id.btn1 -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理普通点击</span></span><br><span class="line">        &#125;</span><br><span class="line">        R.id.btn2 -&gt; view.determineTriggerSingleClick &#123;</span><br><span class="line">            <span class="comment">// 处理单次点击</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据绑定">数据绑定</h3>
<p>使用 DataBinding 的时候，有时会在布局文件中直接设置点击事件，于是在 <code>View.onSingleClick</code> 上增加 <code>@BindingAdapte</code> 注解，实现在布局文件中设置单次点击事件，并对代码做出调整，这个时候需要将项目中 <code>listener: (View) -&gt; Unit</code> 替换成 <code>listener: View.OnClickListener</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(</span></span><br><span class="line"><span class="meta">    *[<span class="meta-string">&quot;singleClickInterval&quot;</span>, <span class="meta-string">&quot;isShareSingleClick&quot;</span>, <span class="meta-string">&quot;onSingleClick&quot;</span>],</span></span><br><span class="line"><span class="meta">    requireAll = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">onSingleClick</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    interval: <span class="type">Int</span>? = SingleClickUtil.singleClickInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    isShareSingleClick: <span class="type">Boolean</span>? = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    listener: <span class="type">View</span>.<span class="type">OnClickListener</span>? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setOnClickListener &#123;</span><br><span class="line">        determineTriggerSingleClick(</span><br><span class="line">            interval ?: SingleClickUtil.singleClickInterval, isShareSingleClick ?: <span class="literal">true</span>, listener</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在布局文件中设置单次点击：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;androidx.appcompat.widget.AppCompatButton</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;@string/btn&quot;</span><br><span class="line">    app:isShareSingleClick=&quot;@&#123;false&#125;&quot;</span><br><span class="line">    app:onSingleClick=&quot;@&#123;()-&gt;viewModel.handleClick()&#125;&quot;</span><br><span class="line">    app:singleClickInterval=&quot;@&#123;2000&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在代码中处理单次点击：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">handleClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 处理单次点击</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>对于直接在 View 上设置点击的地方，如果需要处理重复点击使用 onSingleClick，不需要处理重复点击则使用原来的 setOnClickListener。</p>
<p>对于间接设置点击的地方，如果需要处理重复点击，则使用 determineTriggerSingleClick 判断是否触发单次点击。</p>
<h2 id="项目地址">项目地址</h2>
<p><a href="https://github.com/TaylorKunZhang/single-click">single-click</a>，觉得用起来很爽的，请不要吝啬你的 Star ！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里热修复Sophix集成与体验</title>
    <url>/2019/09/10/sophix-integration/</url>
    <content><![CDATA[<p>热更新很早就想体验一下了，最近工作不是很忙，腾出来一些时间体验了一下，感觉还是挺爽的。</p>
<p>开发环境：</p>
<ul>
<li><code>Android Studio 3.5</code></li>
<li><code>com.aliyun.ams:alicloud-android-hotfix:3.2.8</code></li>
</ul>
<span id="more"></span>
<h2 id="创建项目">创建项目</h2>
<p>为了贴近实际的开发场景，在项目中引入了自己创建的基础库框架：</p>
<p><img src="base-lib.jpg" alt=""></p>
<p>项目采用了组件化，项目结构如下：</p>
<ul>
<li>app：壳项目，包含了 MainActivity 和 Application。</li>
<li>common：通用组件，包含通用依赖库声明，还有基类界面和组件功能接口。</li>
<li>launch：启动组件，包含一个 SplashActivity。</li>
<li>home：首页组件，包含一个HomeFragment。</li>
<li>user：用户组件，包含一个 UserFragment 和 一个 WebActivity，WebActivity里面是空的，只是声明了一个类，继承自 Activity，没有布局文件，只是在 <code>AndroidManifest.xml</code> 中配置了该类。</li>
</ul>
<p><img src="project-structure.jpg" alt=""></p>
<h2 id="集成Sophix">集成Sophix</h2>
<h3 id="1-创建产品及应用">1. 创建产品及应用</h3>
<p>先创建产品及应用，可以参考阿里云官方文档：<a href="https://help.aliyun.com/document_detail/53238.html">创建产品及应用</a>。</p>
<h3 id="2-集成SDK">2. 集成SDK</h3>
<h4 id="2-1-添加依赖">2.1 添加依赖</h4>
<p>在项目的 <code>build.gradle</code> 添加：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">&quot;http://maven.aliyun.com/nexus/content/repositories/releases&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 app 的 <code>build.gradle</code> 中添加：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 阿里热修复</span></span><br><span class="line">    implementation <span class="string">&#x27;com.aliyun.ams:alicloud-android-hotfix:3.2.8&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-声明权限">2.2 声明权限</h4>
<p>在 <code>AndroidManifest.xml</code> 中声明 Sophix 需要的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;! -- 网络权限 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line">&lt;! -- 外部存储读权限，调试工具加载本地补丁需要 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>READ_EXTERNAL_STORAGE</code>权限属于Dangerous Permissions，仅调试工具获取外部补丁需要，不影响线上发布的补丁加载，调试时请自行做好android6.0以上的运行时权限获取。</p>
</blockquote>
<h4 id="2-3-配置账号信息">2.3 配置账号信息</h4>
<p>在 <code>AndroidManifest.xml</code> 中间的 <code>application</code> 节点下添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;com.taobao.android.hotfix.IDSECRET&quot;</span><br><span class="line">    android:value=&quot;App ID&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;</span><br><span class="line">    android:value=&quot;App Secret&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;</span><br><span class="line">    android:value=&quot;RSA密钥&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以不在这里配置账号信息，因为 App ID/App Secret 将被用于计量计费，处于安全考虑，官方建议在代码中使用 setSecretMetaData 这个方法设置账号信息，这个放在后面讲。</p>
</blockquote>
<h4 id="2-4-配置混淆">2.4 配置混淆</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基线包使用，生成mapping.txt</span><br><span class="line">-printmapping mapping.txt</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">-keep class com.taobao.sophix.**&#123;*;&#125;</span><br><span class="line">-keep class com.ta.utdid2.device.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.alibaba.sdk.android.utils.**</span><br><span class="line"></span><br><span class="line"># 防止inline</span><br><span class="line">-dontoptimize</span><br></pre></td></tr></table></figure>
<h4 id="2-5-不使用R8">2.5 不使用R8</h4>
<p>在项目的 <code>gradle.properties</code> 文件中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 热更新混淆需要使用-applymapping mapping.txt，而R8对这个支持的不是很好，所以暂不使用R8</span><br><span class="line">android.enableR8&#x3D;false</span><br></pre></td></tr></table></figure>
<p>一般情况下，正式环境的代码是混淆了的，为了让热更新工作正常，对于补丁包，在混淆的时候，需要使用最初包（官方称为基线包）生成的 mapping 文件，这样补丁包中的混淆规则会和最初包保持一致。</p>
<p>为了达到上述的效果，需要使用<code>-applymapping mapping.txt</code>，在 <code>Android Studio 3.5</code> 上，R8 已经是默认的混淆工具，但是 R8 对这条指令支持的不是很好，我在尝试的时候，一直打包失败，在询问了官方技术支持后，选择不使用 R8。</p>
<p><img src="reasons-for-not-using-R8.jpg" alt=""></p>
<h4 id="2-6-初始化SDK">2.6 初始化SDK</h4>
<h5 id="2-6-1-新建SophixStubApplication">2.6.1 新建SophixStubApplication</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Keep;</span><br><span class="line"><span class="keyword">import</span> androidx.multidex.MultiDex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.taobao.sophix.SophixApplication;</span><br><span class="line"><span class="keyword">import</span> com.taobao.sophix.SophixEntry;</span><br><span class="line"><span class="keyword">import</span> com.taobao.sophix.SophixManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SophixStubApplication</span> <span class="keyword">extends</span> <span class="title">SophixApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Sophix账号信息，如果在AndroidManifest.xml配置了，这里就不需要配置了，</span></span><br><span class="line">    <span class="comment">// 如果在代码中和AndroidManifest.xml同时配置了账号信息，以代码中的为准。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_ID = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_SECRET = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RSA_SECRET = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 用户自定义aes秘钥, 会对补丁包采用对称加密。</span></span><br><span class="line">    <span class="comment">// 这个参数值必须是16位数字或字母的组合，是和补丁工具设置里面AES Key保持完全一致, </span></span><br><span class="line">    <span class="comment">// 补丁才能正确被解密进而加载。此时平台无感知这个秘钥, </span></span><br><span class="line">    <span class="comment">// 所以不用担心阿里云移动平台会利用你们的补丁做一些非法的事情。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES_KEY = <span class="string">&quot;12djahdaufdaldha&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OnPatchLoadStatusListener onPatchLoadStatusListener = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处SophixEntry应指定真正的Application，并且保证RealApplicationStub类名不被混淆。</span></span><br><span class="line">    <span class="meta">@Keep</span></span><br><span class="line">    <span class="meta">@SophixEntry(Application.class)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RealApplicationStub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方法数超过65536限制，这个应在initSophix之前调用</span></span><br><span class="line">        <span class="comment">// 原来的Application里面去除MultiDex，避免重复调用导致问题。</span></span><br><span class="line">        MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        initSophix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOnPatchLoadStatusListener</span><span class="params">(OnPatchLoadStatusListener listener)</span> </span>&#123;</span><br><span class="line">        onPatchLoadStatusListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSophix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String appVersion = <span class="string">&quot;0.0.0&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            appVersion = <span class="keyword">this</span>.getPackageManager()</span><br><span class="line">                    .getPackageInfo(<span class="keyword">this</span>.getPackageName(), <span class="number">0</span>)</span><br><span class="line">                    .versionName;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SophixManager instance = SophixManager.getInstance();</span><br><span class="line">        instance.setContext(<span class="keyword">this</span>)</span><br><span class="line">                .setAppVersion(appVersion)</span><br><span class="line">                <span class="comment">// 设置账号信息</span></span><br><span class="line">                .setSecretMetaData(APP_ID, APP_SECRET, RSA_SECRET)</span><br><span class="line">                <span class="comment">// 设置自定义aes秘钥</span></span><br><span class="line">                .setAesKey(AES_KEY)</span><br><span class="line">                .setEnableDebug(<span class="keyword">false</span>) </span><br><span class="line">                .setPatchLoadStatusStub((mode, code, info, handlePatchVersion) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onPatchLoadStatusListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        onPatchLoadStatusListener.onLoad(mode, code, info, handlePatchVersion);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPatchLoadStatusListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">int</span> code, String info, <span class="keyword">int</span> handlePatchVersion)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-2-配置SophixStubApplication">2.6.2 配置SophixStubApplication</h5>
<p>修改 <code>AndroidManifest.xml</code> 文件，移除原本的 Application，设置为 SophixStubApplication：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:name=&quot;.application.SophixStubApplication&quot; </span><br><span class="line">        .../&gt;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-3-注意事项">2.6.3 注意事项</h5>
<h6 id="2-6-3-1-使用Java编写SophixStubApplication">2.6.3.1 使用Java编写SophixStubApplication</h6>
<p>在实际项目中，我基本上都是使用 Kotlin 开发，对于 SophixStubApplication 应该使用 Java 编写，参考自 <a href="https://help.aliyun.com/knowledge_detail/59422.html">Hotfix补丁工具报错排查步骤</a>。</p>
<p><img src="reasons-for-SophixStubApplication-coding-by-java.jpg" alt=""></p>
<h6 id="2-6-3-2-不要在SophixStubApplication写业务逻辑">2.6.3.2 不要在SophixStubApplication写业务逻辑</h6>
<p>SophixStubApplication 是 Sophix 入口类，专门用于初始化 Sophix，不应包含任何业务逻辑。</p>
<p>此类必须继承自 SophixApplication，onCreate 方法不需要实现。</p>
<p>此类不应与项目中的其他类有任何互相调用的逻辑，必须完全做到隔离。</p>
<p>注意原先 Application里不需要再重复初始化 Sophix，并且需要避免混淆原先 Application 类。</p>
<h4 id="2-7-添加tag（可选）">2.7 添加tag（可选）</h4>
<p>可以通过 setTags接口 [v3.2.7新增]，设置端上拉取补丁包时的标签，可以支持条件更为丰富的灰度发布，以下为简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; tags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">tags.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//此处调用在queryAndLoadNewPatch()方法前</span></span><br><span class="line">SophixManager.getInstance().setTags(tags)；</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; tags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">tags.add(<span class="string">&quot;production&quot;</span>);</span><br><span class="line"><span class="comment">//此处调用在queryAndLoadNewPatch()方法前</span></span><br><span class="line">SophixManager.getInstance().setTags(tags)；</span><br></pre></td></tr></table></figure>
<p><img src="gray-release-tag.jpg" alt=""></p>
<p>如上，设置不同的tags，同一版本号下，可以打两个或者多个基线包，线上发布时用production的基线包，测试环境用test的基线包，这样就可以测试同一版本号下的同一个补丁了，两个环境互不影响。tags可以add多个，结构为前后非空字符串即可。生成补丁时，用同样tags的基线包和修复包。</p>
<h4 id="2-8-处理补丁加载回调">2.8 处理补丁加载回调</h4>
<p>在 SophixStubApplication 中，并没有写补丁加载回调处理逻辑，而是创建了一个接口，通过观察者模式的方式把处理逻辑放在外面处理。这样的目的是，SophixManager 初始化后热更新才开始工作，写在初始化之前的代码热更新是不能作用到的。</p>
<p>在本项目中，把处理逻辑放在了实际的 Application 中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        SophixStubApplication.setOnPatchLoadStatusListener &#123; mode, code, info, handlePatchVersion -&gt;</span><br><span class="line">            <span class="keyword">when</span> (code) &#123;</span><br><span class="line">                PatchStatus.CODE_LOAD_SUCCESS -&gt; &#123;</span><br><span class="line">                    LogUtil.i(<span class="string">&quot;sophix load patch success!&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                PatchStatus.CODE_LOAD_RELAUNCH -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 补丁加载成功，需要重启App生效</span></span><br><span class="line">                    <span class="comment">// 我这里的逻辑是杀死App，100毫秒后重启App</span></span><br><span class="line">                    LogUtil.i(<span class="string">&quot;sophix preload patch success. restart app to make effect.&quot;</span>)</span><br><span class="line">                    RestartAppTool.restart(<span class="keyword">this</span>, <span class="number">100</span>, packageName)</span><br><span class="line">                    SophixManager.getInstance().killProcessSafely()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    LogUtil.i(<span class="string">&quot;sophix load error, code is <span class="variable">$code</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一点需要注意，不可以直接调用 <code>Process.killProcess(Process.myPid())</code> 来杀进程，这样会扰乱 Sophix 的内部状态。因此如果需要杀死进程，建议调用 <code>SophixManager.getInstance().killProcessSafely() </code> 杀死进程，该方法会在内部做一些适当处理后才杀死本进程。</p>
</blockquote>
<h4 id="2-9-增加检查补丁更新逻辑">2.9 增加检查补丁更新逻辑</h4>
<p>阿里 Sophix 的收费方式是按调用 <strong><code>queryAndLoadNewPatch</code></strong> 方法的次数收费，每月有一定的免费阈值：</p>
<ul>
<li>月活设备(MAU): 5万。每个账号，每月5万台设备免费。</li>
<li>日均查询次数：20次。每个账号下的每个应用平均到每台设备，一天免费查补丁询20次。</li>
<li>补丁分发：完全不做次数限制，不额外收取流量费。</li>
</ul>
<p><strong>请谨慎调用 <code>queryAndLoadNewPatch</code></strong>。</p>
<p>因为是 Demo，我这里的处理逻辑是很简单，首页有一个按钮，点击一下就调用一次 <code>queryAndLoadNewPatch</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.initListener()</span><br><span class="line">  </span><br><span class="line">    btnCheckUpdate.onClick &#123;</span><br><span class="line">        <span class="comment">// 检查更新</span></span><br><span class="line">        LogUtil.i(<span class="string">&quot;检查更新&quot;</span>)</span><br><span class="line">        SophixManager.getInstance().queryAndLoadNewPatch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打最初包（基线包）">打最初包（基线包）</h2>
<p>项目效果：</p>
<p><img src="base-app.gif" alt=""></p>
<h3 id="1-备份最初包">1. 备份最初包</h3>
<p>将 <code>app/build/outputs/apk/release</code> 下的正式包备份，重命名为 <code>app-release-0.apk</code>。</p>
<h3 id="2-移动maping-txt">2. 移动maping.txt</h3>
<p>将 <code>app/build/outputs/mapping/release</code> 路径下的 <code>maping.txt </code> 移动到 <code>/app</code> 路径下,</p>
<h3 id="3-修改混淆文件">3. 修改混淆文件</h3>
<p>将原来的混淆文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基线包使用，生成mapping.txt</span><br><span class="line">-printmapping mapping.txt</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">-keep class com.taobao.sophix.**&#123;*;&#125;</span><br><span class="line">-keep class com.ta.utdid2.device.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.alibaba.sdk.android.utils.**</span><br><span class="line"></span><br><span class="line"># 防止inline</span><br><span class="line">-dontoptimize</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修复后的项目使用，保证混淆结果一致</span><br><span class="line">-applymapping mapping.txt</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">-keep class com.taobao.sophix.**&#123;*;&#125;</span><br><span class="line">-keep class com.ta.utdid2.device.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.alibaba.sdk.android.utils.**</span><br><span class="line"></span><br><span class="line"># 防止inline</span><br><span class="line">-dontoptimize</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个改动是为了接下来打热修复补丁，如果接下来要发新版本（版本号需要变动），则还是使用 <code>-printmapping mapping.txt</code>。</p>
</blockquote>
<h2 id="第一次热更新-修改资源">第一次热更新-修改资源</h2>
<h3 id="1-更新代码">1. 更新代码</h3>
<ol>
<li>
<p>更换Splash的背景图片，不修改图片的名字，注意：SplashActivity没有设置布局文件，而是通过设置主题的方式设置的背景图片：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.SplashActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">    android:screenOrientation=&quot;portrait&quot;</span><br><span class="line">    android:theme=&quot;@style/SplashTheme&quot; &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;SplashTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;AppTheme&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowContentOverlay&quot;</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 启动页背景 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/launch_splash_1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>替换首页第一张图片，不修改图片的名字，注意该图片是放在 drawable 文件下。</p>
<p>替换首页第二张图片，不修改图片的名字，注意该图片是放在 assets 文件下。</p>
<p>在布局文件中修改按钮文本的颜色。</p>
<p>在字符串资源文件中修改按钮的文本。</p>
</li>
<li>
<p>替换我的第一张图片，修改图片的名字，注意该图片是放在 drawable 文件下。</p>
<p>替换我的第二张图片，修改图片的名字，注意该图片是放在 assets 文件下。</p>
<p>在布局文件中修改按钮文本的颜色。</p>
<p>在字符串资源文件中修改按钮的文本。</p>
<p>替换我的跳转至百度按钮点击事件中的toast文案。</p>
</li>
</ol>
<h3 id="2-生成补丁">2. 生成补丁</h3>
<h4 id="2-1-生成新包">2.1 生成新包</h4>
<p>运行打包命令，生成新包，重命名为 <code>app-release-1.apk</code>。</p>
<h4 id="2-2-下载打补丁工具">2.2 下载打补丁工具</h4>
<p>如果没有打补丁工具 SophixPatchTool，则可以通过点击以下链接下载：</p>
<ul>
<li><a href="http://ams-hotfix-repo.oss-cn-shanghai.aliyuncs.com/SophixPatchTool_macos.zip">点击下载 Mac 版本打包工具</a></li>
<li><a href="http://ams-hotfix-repo.oss-cn-shanghai.aliyuncs.com/SophixPatchTool_windows.zip">点击下载 Windows 版本打包工具</a></li>
<li><a href="http://ams-hotfix-repo.oss-cn-shanghai.aliyuncs.com/SophixPatchTool_linux.zip">点击下载 Linux 版本打包工具</a></li>
</ul>
<h4 id="2-3-选择包">2.3 选择包</h4>
<p>运行打补丁工具，选择包：</p>
<p><img src="choose-apk.jpg" alt=""></p>
<h4 id="2-4-调整设置">2.4 调整设置</h4>
<p><img src="patch-settings.jpg" alt=""></p>
<h4 id="2-5-调整高级">2.5 调整高级</h4>
<p><img src="patch-advanced-settings.jpg" alt=""></p>
<blockquote>
<p>注意，这里如果勾选了检查初始化，打补丁工具会检查 SophixStubApplication 中的代码，不能包含非系统API，会报错。如果使用了 AndroidX 的 MultiDex，工具也会报错，可以先不勾选检查初始化，自行确定SophixStubApplication中无其他非系统API的使用，该工具后面会对AndroidX的库进行识别。</p>
</blockquote>
<p>其他选项，请按需自行选择是否勾选。</p>
<h4 id="2-6-生成Patch">2.6 生成Patch</h4>
<p>点击按钮 <code>GO!</code>，生成补丁。</p>
<h3 id="3-添加版本">3. 添加版本</h3>
<p>进入移动研发平台 EMAS -&gt; 选择创建的产品 -&gt; 移动热修复 -&gt; 补丁管理，然后点击添加版本按钮，填写版本。</p>
<p><img src="add-version.jpg" alt=""></p>
<p><strong>特别注意</strong>：这里的版本，必须和代码中 <code>setAppVersion</code> 的内容<strong>保持完全一致</strong>，新版控制台版本号已无限制，字符串即可。</p>
<p>在 SophixStubApplication 的代码中，我们选择的使用App的 <code>versionName</code>  作为 <code>setAppVersion</code> 的参数，那么这里填写的内容就是对应版本 App 的 <code>versionName</code>  。</p>
<p>我在这里就踩坑了，之前上传 App 到应用市场，应用市场都会读取 Apk 中的版本号，不用手动填写，我以为这里也是一样。以为填写版本号是为了方便用户使用，所以随手就加了 “v” 作为前缀，如下图所示：</p>
<p><img src="add-version-wrong.jpg" alt=""></p>
<p>结果，在补丁发布后，App始终都检测不到又新补丁，一度怀疑人生。</p>
<h3 id="4-上传补丁">4. 上传补丁</h3>
<p><img src="upload_patch.jpg" alt=""></p>
<blockquote>
<p>目前支持的补丁大小最大为30MB，参考自<a href="https://help.aliyun.com/knowledge_detail/125248.html">移动热修复：补丁大小有什么限制？</a></p>
</blockquote>
<h3 id="5-本地测试">5. 本地测试</h3>
<p><a href="http://ams-hotfix-repo.oss-cn-shanghai.aliyuncs.com/hotfix_debug_tool-release.apk">下载本地调试工具</a>，把调试工具和 <code>app-release-0.apk</code> 都安装到手机上。</p>
<p>先打开App，再打开调用工具，点击连接应用，</p>
<p>鼠标悬停在提示位置：</p>
<p><img src="local-test-scan-tip.jpg" alt=""></p>
<p>点击扫描二维码，安装补丁，重启App，查看App是否生效：</p>
<p><img src="local-test-patch.gif" alt=""></p>
<h3 id="6-灰度测试">6. 灰度测试</h3>
<p>灰度发布的时候，可以指定前面提到的tag。</p>
<p><img src="gray-release-tag.jpg" alt=""></p>
<p>测试效果：</p>
<p><img src="gray-test.gif" alt=""></p>
<h3 id="7-正式上线">7. 正式上线</h3>
<p>经过本地测试和灰度测试，确认无误后选择全量发布：</p>
<p><img src="full-release.jpg" alt=""></p>
<h3 id="8-热更新结果">8. 热更新结果</h3>
<table>
<thead>
<tr>
<th>变动项</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>更换Splash的背景图片，不修改图片的名字，注意该图片是放在 drawable 文件下且通过主题设置</td>
<td>未生效</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>替换首页第一张图片，不修改图片的名字，注意该图片是放在 drawable 文件下</td>
<td>生效</td>
</tr>
<tr>
<td>替换首页第二张图片，不修改图片的名字，注意该图片是放在 assets 文件下</td>
<td>未生效</td>
</tr>
<tr>
<td>在布局文件中修改按钮文本的颜色</td>
<td>生效</td>
</tr>
<tr>
<td>在字符串资源文件中修改按钮的文本</td>
<td>生效</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>替换我的第一张图片，修改图片的名字，注意该图片是放在 drawable 文件下</td>
<td>生效</td>
</tr>
<tr>
<td>替换我的第二张图片，修改图片的名字，注意该图片是放在 assets 文件下</td>
<td>生效</td>
</tr>
<tr>
<td>在布局文件中修改按钮文本的颜色</td>
<td>生效</td>
</tr>
<tr>
<td>在字符串资源文件中修改按钮的文本</td>
<td>生效</td>
</tr>
<tr>
<td>替换我的跳转至百度按钮点击事件中的toast文案</td>
<td>生效</td>
</tr>
</tbody>
</table>
<h2 id="第二次热更新-使用占位Activity">第二次热更新-使用占位Activity</h2>
<h3 id="1-更新代码-2">1. 更新代码</h3>
<ol>
<li>为空的 WebActivity 创建布局文件，增加路由，接收路由参数url，用 WebView 显示 url 的内容。</li>
<li>我的页面跳转至百度按钮点击，跳转至 webActivity，携带参数为百度网页地址。</li>
<li>更换Splash的背景图片，修改图片的名字。</li>
</ol>
<h3 id="2-生成补丁并发布">2. 生成补丁并发布</h3>
<p>重复的步骤不再展开，新生成的包命名为 <code>app-release-2.apk</code>，<strong>注意选择包的时候，旧包为 <code>app-release-0.apk</code> 而不是 <code>app-release-1.apk</code>。</strong></p>
<h3 id="3-热更新结果">3. 热更新结果</h3>
<p><img src="placeholder-activity.gif" alt=""></p>
<table>
<thead>
<tr>
<th>变动项</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>增加空 WebActivity 内容，展示指定 url 的网页内容</td>
<td>生效</td>
</tr>
<tr>
<td>我的页面跳转至百度按钮点击，跳转至 webActivity，携带参数为百度网页地址。</td>
<td>生效</td>
</tr>
<tr>
<td>更换Splash的背景图片，修改图片的名字</td>
<td>不生效</td>
</tr>
</tbody>
</table>
<h2 id="第三次热更新-新增So和Style">第三次热更新-新增So和Style</h2>
<h3 id="1-更新代码-3">1. 更新代码</h3>
<ol>
<li>
<p>集成腾讯浏览服务TBS（该框架中包含so文件），将 WebActivity 中的系统 WebView 替换为 TBS 的 WebView。</p>
</li>
<li>
<p>进入 WebActivity 的时候显示一个 Toast，确认当前显示的已经集成 TBS 的 Activity。</p>
</li>
<li>
<p>在我的页面新增两个TextView，除了位置属性外，其他属性全部使用 Style。第一个TextStyle中部分是实际值，部分是引用，第二个 TextStyle 除了 <code>android:gravity</code> 全部使用引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;UserTestTextStyle1&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_width&quot;</span>&gt;</span>80dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_height&quot;</span>&gt;</span>30dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@color/common_red_F41<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span> <span class="attr">tools:ignore</span>=<span class="string">&quot;SpUsage&quot;</span>&gt;</span>20dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>@color/common_white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:text&quot;</span>&gt;</span>@string/user_test_style_1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;UserTestTextStyle2&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_width&quot;</span>&gt;</span>@dimen/TestText2Width<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_height&quot;</span>&gt;</span>@dimen/TestText2height<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@color/TestText2Background<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span> <span class="attr">tools:ignore</span>=<span class="string">&quot;SpUsage&quot;</span>&gt;</span>@dimen/TestText2TextSize<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>@color/TestText2TextColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:text&quot;</span>&gt;</span>@string/user_test_style_2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;TestText2Width&quot;</span>&gt;</span>80dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;TestText2height&quot;</span>&gt;</span>30dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;TestText2Background&quot;</span>&gt;</span>#FF4A1E<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;TestText2TextSize&quot;</span>&gt;</span>20dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;TestText2TextColor&quot;</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-生成补丁并发布-2">2. 生成补丁并发布</h3>
<p>重复的步骤不再展开，新生成的包命名为 <code>app-release-3.apk</code>，<strong>注意选择包的时候，旧包为 <code>app-release-0.apk</code> 而不是 <code>app-release-2.apk</code>。</strong></p>
<h3 id="3-热更新结果-2">3. 热更新结果</h3>
<p><img src="add-so-file.gif" alt=""></p>
<table>
<thead>
<tr>
<th>变动项</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>集成腾讯浏览服务 TBS</td>
<td>生效</td>
</tr>
<tr>
<td>WebActivity 进入的时候显示 Toast</td>
<td>生效</td>
</tr>
<tr>
<td>我的页面新增TestView，使用 Style，在 Style 中部分使用实际值，部分使用引用</td>
<td>生效</td>
</tr>
<tr>
<td>我的页面新增TestView，使用 Style，在 Style 中除了 <code>android:gravity</code> 全部使用引用</td>
<td>生效</td>
</tr>
</tbody>
</table>
<h2 id="第四次热更新-修改Style">第四次热更新-修改Style</h2>
<h3 id="1-更新代码-4">1. 更新代码</h3>
<p>修改我的页面两个 TextView 的 style，第一个直接修改实际值，第二个修改引用内容的值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;UserTestTextStyle1&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_width&quot;</span>&gt;</span>140dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_height&quot;</span>&gt;</span>50dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@color/common_green_07<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span> <span class="attr">tools:ignore</span>=<span class="string">&quot;SpUsage&quot;</span>&gt;</span>30dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>@color/common_red_F41<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:text&quot;</span>&gt;</span>@string/user_test_style_1_1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;UserTestTextStyle2&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_width&quot;</span>&gt;</span>@dimen/TestText2Width<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_height&quot;</span>&gt;</span>@dimen/TestText2height<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>@color/TestText2Background<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span> <span class="attr">tools:ignore</span>=<span class="string">&quot;SpUsage&quot;</span>&gt;</span>@dimen/TestText2TextSize<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>@color/TestText2TextColor<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:text&quot;</span>&gt;</span>@string/user_test_style_2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;TestText2Width&quot;</span>&gt;</span>140dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;TestText2height&quot;</span>&gt;</span>50dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;TestText2Background&quot;</span>&gt;</span>#07C27F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;TestText2TextSize&quot;</span>&gt;</span>30dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;TestText2TextColor&quot;</span>&gt;</span>#FF4A1E<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-生成补丁并发布-3">2. 生成补丁并发布</h3>
<p>重复的步骤不再展开，新生成的包命名为 <code>app-release-4.apk</code>，<strong>注意选择包的时候，旧包为 <code>app-release-0.apk</code> 而不是 <code>app-release-3.apk</code>。</strong></p>
<h3 id="3-热更新结果-3">3. 热更新结果</h3>
<p><img src="modify-style.gif" alt=""></p>
<table>
<thead>
<tr>
<th>变动项</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Style直接修改实际值</td>
<td>生效</td>
</tr>
<tr>
<td>Style修改引用内容的值</td>
<td>生效</td>
</tr>
</tbody>
</table>
<h2 id="第五次热更新-修改主题">第五次热更新-修改主题</h2>
<h3 id="1-更新代码-5">1. 更新代码</h3>
<p>修改启动页主题，取消全屏，将状态栏颜色修改为红色。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;SplashTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;AppTheme&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/common_red_F41<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowContentOverlay&quot;</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 启动页背景 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/launch_splash_2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-生成补丁并发布-4">2. 生成补丁并发布</h3>
<p>重复的步骤不再展开，新生成的包命名为 <code>app-release-5.apk</code>，<strong>注意选择包的时候，旧包为 <code>app-release-0.apk</code> 而不是 <code>app-release-4.apk</code>。</strong></p>
<h3 id="3-热更新结果-4">3. 热更新结果</h3>
<p><img src="modify-theme.gif" alt=""></p>
<table>
<thead>
<tr>
<th>变动项</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Style直接修改实际值</td>
<td>不生效</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>经过简单几轮测试下来，热更新可以做到以下几点：</p>
<ol>
<li>支持对应用Application的代码调整（非SophixStubApplication）;</li>
<li>支持混淆；</li>
<li>支持对代码的调整；</li>
<li>支持 <a href="https://github.com/alibaba/ARouter">ARouter</a>，开始的时候自己还是有点担心不支持 <a href="https://github.com/alibaba/ARouter">ARouter</a>。</li>
<li>支持 res 中资源除主题之外的修改。</li>
<li>支持更新 assest 中的图片，但是必须是新增图片，即图片名称必须修改，不能使用原图片名称。</li>
</ol>
<p>同样也有一些还做不到的：</p>
<ol>
<li>不支持修改 <code>AndroidManifest.xml</code>，所以新增 Activity ，新增权限等都不能生效。也不是没有办法解决，Activity 可以通过提前配置空白 Activity 占位的形式解决。</li>
<li>不支持修改 Activity 的主题，就算只是更换了 Activity 主题背景图片，无论是该图片是新增，还是保留原图片名称，只替换内容，都不支持。</li>
<li>不支持更新 assest 中的图片内容，保留原图片名称。</li>
</ol>
<p>对于官方宣传的应用场景：线上bug紧急修复和快速轻量版本升级，我认为达到了我的预期。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>热修复</tag>
        <tag>Sophix</tag>
      </tags>
  </entry>
</search>
